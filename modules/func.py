"""
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.
If not, see <https://www.gnu.org/licenses/>.
"""

"""
func

Function definitions 
"""

import bpy 
import bmesh
import math
from . import etc
from . import static_data
import numpy as np
import random
import colorsys
import string 
import csv
from ast import literal_eval

# Attribute related
# ------------------------------------------

# get

def get_active_attribute(obj):
    """Bug bypass if attributes.active returns none

    Args:
        obj (ref): reference to the object to get the active attribute from
    """

    a = obj.data.attributes.active

    if a is None:
        return obj.data.attributes[obj.data.attributes.active_index]
    return a

def get_attribute_types(attribute):
    """Checks for attribute type, eg hidden, autogenerated, and other.

    Args:
        attrib_name (string): Name of the attribute

    Returns:
        list: List of data.EAttributeType
    """

    at = []

    # check for hidden
    if attribute.name.startswith('.'):
        at.append(static_data.EAttributeType.HIDDEN)

    # check for presets
    if attribute.name in static_data.defined_attributes.keys():
            at += static_data.defined_attributes[attribute.name].types
    else:
        at.append(static_data.EAttributeType.NORMAL)

    return at

def get_is_attribute_valid_for_manual_val_assignment(attribute):
    """Checks if the attribute is a valid attribute to assign values to it in edit mode

    Args:
        attrib_name (string): Name of the attribute

    Returns:
        list: List of data.EAttributeType
    """
    return not bool(len([atype for atype in get_attribute_types(attribute) if atype in [static_data.EAttributeType.READONLY, static_data.EAttributeType.NOTPROCEDURAL]]))

def get_attribute_value_propname(attribute = None, data_type:str = ""):
    """Gets the property name of attribute value. Some values are stored in .vector others in .value etc.

    Args:
        attribute (Reference): Attribute reference variable
        data_type (str): alternative to attribute input field

    Returns:
        string: Attribute property name
    """

    if data_type == '':
        data_type = attribute.data_type

    if data_type in ["FLOAT_VECTOR", "FLOAT2"]:
        return "vector"
    elif data_type in ["FLOAT_COLOR", "BYTE_COLOR"]:
        return "color"
    else:
        return "value"

def get_attribute_values(attribute, obj):
    """Reads all attribute values using foreach_get

    Args:
        attribute (Reference): Attribute reference variable
        obj (Reference): Reference to an 3D object that stores that attribute

    Raises:
        etc.MeshDataReadException: If source data type is not implemented
        
    Returns:
        list: Attribute values, data type unchanged
    """

    value_attrib_propname = get_attribute_value_propname(attribute)
    dt = attribute.data_type

    if is_verbose_mode_enabled():
        print(f"Getting {attribute.name} values: data type = {dt} ({attribute.data_type}), prop = {value_attrib_propname}, len = {len(attribute.data)}" )

    
    if dt == "FLOAT":
        a_vals = [0.0] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "INT":
        a_vals = [0] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "FLOAT_VECTOR":
        a_vals = [0.0] * (len(attribute.data) * 3) # why not Vector()? 
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2]) for i in range(0, len(a_vals), 3)]
    elif dt == "FLOAT_COLOR":
        a_vals = [0.0] * (len(attribute.data) * 4)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2], a_vals[i+3]) for i in range(0, len(a_vals), 4)]
    elif dt == "BYTE_COLOR":
        a_vals = [0.0] * (len(attribute.data) * 4)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2], a_vals[i+3]) for i in range(0, len(a_vals), 4)]
    elif dt == "BOOLEAN":
        a_vals = [False] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "FLOAT2":
        a_vals = [0.0] * (len(attribute.data) * 2)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1]) for i in range(0, len(a_vals), 2)]
    elif dt == "INT32_2D":
        a_vals = [0] * (len(attribute.data) * 2)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1]) for i in range(0, len(a_vals), 2)]
    elif dt == "QUATERNION":
        a_vals = [0.0] * (len(attribute.data) * 4)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2], a_vals[i+3]) for i in range(0, len(a_vals), 4)]
    elif dt == "INT8":
        a_vals = [0] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "STRING":
        # Foreach set get does not support strings.
        a_vals = []
        for entry in attribute.data:
            a_vals.append(entry.value)
        return a_vals
    else:
        raise etc.MeshDataReadException('get_attrib_values', f"Data type {dt} is unsupported.")

def get_attribute_default_value(attribute = None, datatype:str = None):
    """Returns the zero value for attribute data type. Does not return a list with the length of the attribute data!

    Args:
        attribute (Reference): Reference to the attribute
        or
        datatype (str): name of the datatype
    
    Raises:
        etc.MeshDataReadException: If source data type is not implemented

    Returns:
        Variable type: The default value for single attribute value
    """
    if attribute is not None:
        datatype = attribute.data_type

    if datatype in static_data.attribute_data_types:
        return static_data.attribute_data_types[datatype].default_value
    else:
        raise etc.MeshDataReadException('get_attrib_default_value', f"Data type {datatype} is unsupported.")

def get_safe_attrib_name(obj, attribute_name, suffix = "Attribute", check_attributes = False):
    """Gets safe attribute name to avoid crashes in some instances.
    ie. Naming attribute the same name as Vertex Group can crash blender.

    Args:
        obj (Reference): 3D Object reference
        attribute_name (str): Name of the attribute to check
        suffix (str, optional): The suffix to add to the name if the name is not safe. Defaults to "Attribute".

    Returns:
        str: Safe attribute name
    """
    while(attribute_name in obj.vertex_groups.keys()):
            if is_verbose_mode_enabled():
                print(f"{attribute_name} exists in vertex groups! Renaming")
            attribute_name += " " + suffix
    
    if check_attributes:
        while(attribute_name in obj.data.attributes):
                if is_verbose_mode_enabled():
                    print(f"{attribute_name} exists in attributes! Renaming")
                attribute_name += " " + suffix
            
    if attribute_name.startswith('.'):
        if is_verbose_mode_enabled():
                print(f"{attribute_name} starts with a dot, renaming")
        attribute_name = attribute_name[1:] 
        

    return attribute_name

def get_random_attribute_of_data_type(context, data_type:str, count=1, no_list = False, src_attribute = None, obj = None, randomize_once = False, no_numpy = False, **kwargs):
    """Returns a list or a single random value of specified data type.

    Args:
        obj (Reference): 3D Object Reference
        data_type (str): Data type string
        count (int): count, set higher than 1 to get a list
        no_list (boolean): Force return a single value instead of a list
        src_attribute (reference): If only a part of the vector has to be randomized the attribute has to be passed 
        obj (reference): If only a part of the vector has to be randomized the object reference has to be passed 
        randomize_once (bool): For lists, returns a single random value repeated for whole length of the list
        no_numpy (bool): If the returned value cannot be of numpy type eg. numpy.int32

        kwargs: (If applicable)
        * range_min                 The minimum random value or length for string
        * range_min                 The maximum random value or length for string
        * bool_probability          The percentage chance of getting a true value
        * string_capital            Whether to use captial letters in strings
        * string_lowercase          Whether to use lowercase letters in strings
        * string_numbers            Whether to use numbers in strings
        * string_special            Whether to use special characters in strings
        * string_custom             Use characters from input range (overrides previous toggles)
        * color_randomize_type      str RGBA HSVA
        * b_vec_{id}                Whether to change the value at vector subelement, vector is usually 4D
        * original_vector           If no_list is true, input is a vector and only some subelements have to be randomized, pass original vector here

    Returns:
        list or variable type: random value(s)
    """
    
    # Float
    if data_type == 'FLOAT':            
        if no_list:
            random.seed()
            return random.uniform(kwargs['range_min'], kwargs['range_max'])
        elif randomize_once:
            random.seed()
            return np.repeat(random.uniform(kwargs['range_min'], kwargs['range_max']), count)
        else:
            return np.random.uniform(low=kwargs['range_min'], high=kwargs['range_max'], size=count)
        
    # Integers
    elif data_type in ['INT', 'INT8']:
        if no_list:
            random.seed()
            return random.randint(kwargs['range_min'], kwargs['range_max'])
        elif randomize_once:
            random.seed()
            return np.repeat(random.randint(kwargs['range_min'], kwargs['range_max']), count)
        else:
            return np.random.randint(low=kwargs['range_min'], high=kwargs['range_max'], size=count)
    
    # Vectors with float sub-elements
    elif data_type in ["FLOAT_VECTOR", "QUATERNION", "INT32_2D", "FLOAT_COLOR", "BYTE_COLOR", 'FLOAT2']:
        
        # support for single values implemented btw
        
        # Get number of elements to randomize
        if no_list or randomize_once:
            substack_len = 1
        else:
            substack_len = count

        use_hsv = kwargs['color_randomize_type'] == 'HSVA' and data_type in ["FLOAT_COLOR", "BYTE_COLOR"]
        v_size = len(static_data.attribute_data_types[data_type].vector_subelements_names)
        stacks = []

        # Check if all vector elements have to be randomized
        v_toggles = []
        for i in range(0, v_size):
            v_toggles.append(kwargs[f'b_vec_{i}'])

        # If not read the original values or get the og vector from kwargs if this is a single random vec
        if not all(v_toggles) or use_hsv:
            if no_list:
                og_vals = [kwargs['original_vector']]
            else:
                og_vals = get_attribute_values(src_attribute, obj)

        # Convert them to HSV if applicable
        if use_hsv:
            for i, subelement in enumerate(og_vals):
                og_vals[i] = color_vector_to_hsv(subelement)

        for subelement in range(0, v_size):
            if v_toggles[subelement]:
                # integer subeleemnts
                if data_type in ["INT32_2D"]:
                    stacks.append(np.random.randint(low=kwargs[f'range_min'][subelement], high=kwargs[f'range_max'][subelement], size=substack_len))

                # float subelements 
                else:
                    value = np.random.uniform(low=kwargs[f'range_min'][subelement], high=kwargs[f'range_max'][subelement], size=substack_len)

                    stacks.append(value)
            else:
                stacks.append([i[subelement] for i in og_vals])
        val = np.column_stack(stacks)
        
        if use_hsv:
            for i, el in enumerate(val):
                print(f'converting {el}')
                val[i] = color_vector_to_rgb(el)
        if no_list:
            return val.tolist()[0] if no_numpy else val[0]
        elif randomize_once:
            val = val.tolist()[0] if no_numpy else val[0]
            return [(val), ] * count
        else:
            return val.tolist() if no_numpy else val

    # String
    elif data_type == "STRING":
        min_len = kwargs['range_min']
        max_len = kwargs['range_max']
        custom_str = kwargs['string_custom']
        characters = []
        if custom_str is not None and custom_str !=  "":
            characters = np.array(list(custom_str)).tile(ceil(max_len/len(custom_str)))
        else:
            if kwargs['string_capital']:
                characters += string.ascii_uppercase
            if kwargs['string_lowercase']:
                characters += string.ascii_lowercase
            if kwargs['string_numbers']:
                characters += string.digits
            if kwargs['string_special']:
                characters += string.printable[62:95]

        def getrndstr(chars, max, min):
            len = round((max-min) * random.random()) + min
            start_id = random.randint(0, max-len)
            
            random.shuffle(chars)
            value = ''.join(chars[start_id:start_id+len+1])
            if is_verbose_mode_enabled:
                print(f"MINLEN: {min}, MAXLEN:{max}, LEN:{len}, Generated string: {value}")
            return value
        
            
        if no_list:
            return getrndstr(characters, max_len, min_len)
        elif randomize_once:
            return np.repeat(getrndstr(characters, max_len, min_len), count)
        else:
            a = []
            for i in range(0, count):
                a.append(getrndstr(characters, max_len, min_len))
            return a
    
    # Boolean
    elif data_type == "BOOLEAN":
        if no_list:
            random.seed()
            return random.uniform(0.0, 1.0) <= kwargs['bool_probability']
        elif randomize_once:
            random.seed()
            return np.repeat(random.uniform(0.0, 1.0) <= kwargs['bool_probability'], count)
        else:
            return [e <= kwargs['bool_probability'] for e in np.random.uniform(low=0.0, high=1.0, size=count)]
    else:
        raise etc.GenericFunctionParameterError("get_random_attribute_of_data_type", f"Data type invalid: \"{data_type}\"")

# set

def set_attribute_values(attribute, value, on_indexes = [], flat_list = False, bugbypass_data_type = "", bugbypass_domain = ""):
    """Sets attribute values. Accepts both lists and single values.
    WARNING: OBJECT MODE REQUIRED

    Args:
        attribute (Reference): Reference to the attribute
        value (list or value): The value or values to set
        on_indexes (list, optional): Indexes to set the value on. Defaults to []. Duplicates WILL NOT be checked
        flat_list (bool, optional): Only for setting ALL values. Used in case when the target accepts vector values (tuples), but the input list is single dimension eg. [3,3,3] instead of [(3,3,3)]. Defaults to False.
        bugbypass_data_type (str, optional): If the console returns "current value '0' matches no enum in 'ByteIntAttribute', '', 'data_type'" specify the string of the data type
        bugbypass_domain (str, optional): If the console returns "current value '0' matches no enum in 'ByteIntAttribute', '', 'data_type'" specify the string of the domain
    Raises:
        etc.MeshDataWriteException: On failure

    Returns:
        Nothing 
    """

    """
    For a mesh of 30,722 vertices
    Setting all values using foreach set only: ~~ 0.013s to finish (ALL values to single one)
    Setting all values using foreach get, foreach set ~~ 0.21s to finish
    Setting all values using for loop over .value ~~ 0.49s to finish
    
    I'm not smart enough to calculate computation complexity, but eyeballing it on multiple meshes resulted in strategy that
    <25% mesh for loop
    >25% mesh, foreach get foreach set
    all just foreach set

    setattr is noticeably slower

    guess it's a call to finally learn how to program and count for real
    """

    if value is None:
        raise etc.MeshDataWriteException("set_attribute_values", f"Input value is NONE")


    is_list = type(value) in [list, np.ndarray]

    # Foreach_set
    # Note: Strings do not support FOREACH_SET
    if is_verbose_mode_enabled():
        print(f"""
SETTING ATTRIBUTE VALUES
ATTRIBUTE: {attribute.name}
VALUE: {value}
ON_INDEXES: {on_indexes}
FLAT_LIST: {flat_list}              
ON_INDEX_FROM_LIST: {is_list}
BUGBYPASS_DATA_TYPE: {bugbypass_data_type != ''}
BUGBYPASS_DOMAIN: {bugbypass_domain != ''}
""")
    
    dt = attribute.data_type if bugbypass_data_type == '' else bugbypass_data_type
    domain = attribute.domain if bugbypass_domain == '' else bugbypass_domain

    if (len(on_indexes) == 0 or len(on_indexes) == len(attribute.data)) and dt != 'STRING' :
        etc.pseudo_profiler("FOR_EACH_START")
        prop_name = get_attribute_value_propname(data_type=dt)
        if is_verbose_mode_enabled():
            print(f"Setting {attribute.name} attribute values for each domain. Expected data length {len(attribute.data)}, input data length {len(value)}")

        # create storage
        if flat_list:
            storage = value
        elif type(value) in [list, np.ndarray]:
            if len(value) != len(attribute.data):
                raise etc.MeshDataWriteException("set_attribute_values", f"Invalid input value data length. Input {len(value)}, expected {len(attribute.data)}")
            
            # convert to single dimension list if of vector type
            if dt in ['FLOAT_VECTOR', 'FLOAT2', 'FLOAT_COLOR', 'BYTE_COLOR', 'INT32_2D', 'QUATERNION']:
                storage = np.array(value).flatten()
                etc.pseudo_profiler("1D LIST CREATED")
            else:
                storage = value
            
        else:
            storage = np.tile(value, len(attribute.data))
        etc.pseudo_profiler("STORAGE_CREATED")
        
        attribute.data.foreach_set(prop_name, storage)
        etc.pseudo_profiler("FOREACH SET DONE")
    # on selected indexes mode
    else:
        if is_verbose_mode_enabled():
            print(f"Setting {attribute.name} attribute values for {len(on_indexes)} domains. ")

        prop = get_attribute_value_propname(data_type=dt)
        
        # FOREACH_GET_FOREACH_SET for > 25%
        foreach_get_from = etc.get_preferences_attrib('set_algo_tweak')
        if len(on_indexes) > len(attribute.data)*foreach_get_from and dt != 'STRING':
            etc.pseudo_profiler("FOREACH_GET_FOREACH_SET")
            if is_verbose_mode_enabled():
                print(f"Using foreach set (on selected indexes)")
            prop_name = get_attribute_value_propname(data_type=dt)
            
            if is_list and len(value) < len(on_indexes):
                raise etc.MeshDataWriteException("set_attribute_values", f"Value input list is shorter [{len(value)}] than index list that the values are supposed to be set on [{len(on_indexes)}]")

            example_attribute_domain_value = value[0] if is_list else value
            storage = np.repeat(example_attribute_domain_value, len(attribute.data))
            attribute.data.foreach_get(prop_name, storage)
            
            if type(example_attribute_domain_value) in [tuple, list, np.ndarray]:
                for i, id in enumerate(on_indexes):
                    for l in range(0, len(example_attribute_domain_value)):
                        storage[id*len(example_attribute_domain_value)+l] = value[i][l] if is_list else value[l]
            else:
                for i, id in enumerate(on_indexes):
                    storage[id] = value[i] if is_list else value
            attribute.data.foreach_set(prop_name, storage)

        # For loop for < 25% mesh selected
        else:
            etc.pseudo_profiler("SET_VAL_ON_SELECTION_START")
            if is_verbose_mode_enabled():
                print(f"Using assign by value")
            if prop == "vector":
                for i, id in enumerate(on_indexes):
                    attribute.data[id].vector = value[i] if is_list else value
            elif prop == "color":
                for i, id in enumerate(on_indexes):
                    attribute.data[id].color = value[i] if is_list else value
            else: # "value"
                for i, id in enumerate(on_indexes):
                    attribute.data[id].value = value[i] if is_list else value

            etc.pseudo_profiler("SET_VAL_ON_SELECTION_END")
                          
def set_attribute_value_on_selection(self, context, obj, attribute, value, face_corner_spill = False):
    """Assigns a single value to all selected domain in edit mode.

    Args:
        context (Reference): Blender context referene
        obj (Reference): 3D Object Reference
        attribute (Reference): Attribute reference
        value (Variable type): The value to set
        face_corner_spill (bool, optional): Enable spilling the value to nearby face corners. Defaults to False.

    Returns:
        bool: Success status
    """

    # Store active attribute name (and test it) !important
    active_attrib_name = attribute.name 
    active_attrib = obj.data.attributes[active_attrib_name]
    
    if is_verbose_mode_enabled():
        print( f"Working on {active_attrib_name} attribute" )

    # Get selection in edit mode, on attribute domain
    etc.pseudo_profiler("EXEC_START_SET_VAL_ON_SEL")
    selected_el = get_mesh_selected_domain_indexes(obj, active_attrib.domain, face_corner_spill)
    etc.pseudo_profiler("GET_SEL_BY_DOMAIN_DONE")

    if not len(selected_el):
        self.report({'ERROR'}, "Invalid selection or no selection")
        return False
    
    active_attrib = obj.data.attributes[active_attrib_name] # !important get_mesh_selected_by_domain changes the reference

    if is_verbose_mode_enabled():
        print(f"Attribute data length: {len(active_attrib.data)}")
        print(f"Selected domains: [{len(selected_el)} total] - {selected_el}")
        print(f"Setting value: {value}")
        a_vals = get_attribute_values(attribute, obj)
        print(f"Pre-set values: {str(a_vals)}")

    # Write the new values
    #selected_el = [i for i, el in enumerate(selected_el) if el]
    #selected_el = [i.index for i in selected_el]
    etc.pseudo_profiler("GET_SEL_EL_INDEX")
    set_attribute_values(active_attrib, value, selected_el)
    etc.pseudo_profiler("SET_VALUES_END")
    if is_verbose_mode_enabled():
        a_vals = get_attribute_values(attribute, obj)
        print(f"Post-set values: {str(a_vals)}")

    return True

def set_active_attribute(obj, attribute_name):
    """Sets active attribute and avoids the bug that might set the invalid attribute as active

    Args:
        obj (Reference): Object Reference
        attribute_name (str): Attribute name
    """
    
    atrr_index = obj.data.attributes.keys().index(attribute_name)
    if is_verbose_mode_enabled():
        print(f"Setting active attribute to {attribute_name}, index {atrr_index}")
    obj.data.attributes.active_index = atrr_index

def convert_attribute(self, obj, attrib_name, mode, domain, data_type):
    """Converts attribute to different type

    Args:
        obj (Reference): 3D Object Reference
        attrib_name (str): Name of the attribute
        mode (enum str): See data.convert_attribute_modes
        domain (enum str): See data.attribute_domains
        data_type (enum str): See data.attribute_data_types

    Raises:
        etc.MeshDataWriteException: On failure
    """

    if is_verbose_mode_enabled():
        print(f"Converting attribute {attrib_name}")
    
    # Auto convert to different data type, if enabled in gui
    attrib = obj.data.attributes[attrib_name]
    
    if attrib is not None:
        set_active_attribute(obj, attrib_name)

        if is_verbose_mode_enabled():
            print(f"Converting {obj.data.attributes.active.name} with settings {mode}, {domain}, {data_type}")

        bpy.ops.geometry.attribute_convert(mode=mode, domain=domain, data_type=data_type)
    else:
        raise etc.MeshDataWriteException('convert_attribute', f"{attrib_name} attribute is None?")


# Mesh related
# ------------------------------------------

# get

def get_mesh_selected_domain_indexes(obj, domain, spill=False):
    """Gets the indexes of selected domain entries in edit mode. (Vertices, edges, faces or Face Corners)

    Args:
        obj (Reference): 3D Object Reference
        domain (str): Mesh Domain
        spill (bool, optional): Enables selection spilling to nearby face corners from selected verts/faces/edges. Defaults to False.

    Raises:
        etc.MeshDataReadException: If domain is unsupported

    Returns:
        list: List of indexes
    """

    if domain == 'POINT': 
        storage = np.zeros(len(obj.data.vertices), dtype=bool)
        obj.data.vertices.foreach_get('select', storage)
        return np.arange(0, len(obj.data.vertices))[storage]
    
    elif domain == 'EDGE': 
        storage = np.zeros(len(obj.data.edges), dtype=bool)
        obj.data.edges.foreach_get('select', storage)
        return np.arange(0, len(obj.data.edges))[storage]
    
    elif domain == 'FACE': 
        storage = np.zeros(len(obj.data.polygons), dtype=bool)
        obj.data.polygons.foreach_get('select', storage)
        return np.arange(0, len(obj.data.polygons))[storage]

    elif domain == 'CORNER': 
        # boneless chicken 
        if spill: 
            # Get selected verts ids
            storage = np.zeros(len(obj.data.vertices), dtype=bool)
            obj.data.vertices.foreach_get('select', storage)
            sel_verts = np.arange(0, len(obj.data.vertices))[storage]
            
            # Get loop assigned verts
            storage = np.zeros(len(obj.data.loops), dtype=int)
            obj.data.loops.foreach_get('vertex_index', storage)

            # Get the loops with the selected verts
            return np.arange(0, len(obj.data.loops))[np.isin(storage, sel_verts)]

        else:
            mesh_selected_modes = bpy.context.scene.tool_settings.mesh_select_mode
            result = [] # ???
            
            # Case: User wants to assign faces
            if mesh_selected_modes[2]: # faces

                # Get selected faces
                face_select = np.zeros(len(obj.data.polygons), dtype=bool)
                obj.data.polygons.foreach_get('select', face_select)
                
                # Get face loop indexes
                #face_loop_start_ids = np.zeros(len(obj.data.polygons), dtype=int)
                #obj.data.polygons.foreach_get('loop_start', face_loop_indices) # why not?

                face_loop_indices = []
                for i in np.arange(0, len(obj.data.polygons))[face_select]:
                    face_loop_indices += obj.data.polygons[i].loop_indices
                return np.unique(face_loop_indices)#[face_select])
            
            # Case User wants to select individual face corners by edge selection (detect same for vert selection)
            else:
                
                # get selected edges
                b_sel_edges = np.zeros(len(obj.data.edges), dtype=bool)
                obj.data.edges.foreach_get('select', b_sel_edges)
                sel_edges = np.arange(0, len(obj.data.edges))[b_sel_edges]
                
                # go away if none selected
                if not len(sel_edges):
                    return []
                
                # get edge indexes for all loops
                loops_edge_index = np.zeros(len(obj.data.loops), dtype=int)
                obj.data.loops.foreach_get('edge_index', loops_edge_index)

                # get loops that are connected to selected edges
                loop_ids_of_selected_edges = np.arange(0, len(obj.data.loops))[np.isin(loops_edge_index, sel_edges)]
                
                if is_verbose_mode_enabled():
                    print(f"The selection might be one of {loop_ids_of_selected_edges} fcs")
                
                for fc in [obj.data.loops[li] for li in loop_ids_of_selected_edges]:
                    
                    # Get face that has this loop
                    for f in obj.data.polygons:
                        if fc.index in f.loop_indices:
                            face = f
                            break

                    if is_verbose_mode_enabled():
                        print(f"Face {face.index} has fc {fc.index}")
                        print(f"Face {face.index} has vts {[v for v in face.vertices]}")
                        print(f"Looking for vert {fc.vertex_index}")
                        print(f"Looking in face {face.index}: {list(obj.data.polygons[face.index].loop_indices)}")

                    valid_edges = []
                    for i in obj.data.polygons[face.index].loop_indices:
                        if b_sel_edges[obj.data.loops[i].edge_index]:
                            edge = obj.data.edges[obj.data.loops[i].edge_index]
                            #print(f"{face.index}: has edge with verts {edge.vertices}")
                            edge_verts = [v for v in edge.vertices]

                            if fc.vertex_index in edge_verts:
                                valid_edges.append(edge.index)
                                #print(f"{edge.index} contains the vert of fc")
                    
                    # check if at least two of those edges are selected

                    if len(valid_edges) > 1:
                        result.append(fc.index)
                
                return result
    
    else:
        raise etc.MeshDataReadException('get_mesh_selected_domain_indexes', f'The {domain} domain is not supported')

def get_filtered_indexes_by_condition(source_data: list, condition:str, compare_value, case_sensitive_string = False, vector_convert_to_srgb= False):
    """Gets indexes of the list that store values that meet selected condition

    Currently only one dimensional lists are supported.

    Args:
        source_data (list): The list with data
        condition (str): The condition to check
        compare_value (variable): The value to check the condition with
        case_sensitive_string (bool, optional): Whether the strings should be compared with case sensitivity or not. Defaults to False.
        convert_to_srgb (bool, optional): When working with BYTE_COLOR, setting the value might be converted to SRGB colorspace
    Returns:
        list: _Indexes of the list that meet the criteria
    """
        # todo flatten the list or handle vectors somehow
        # there has to be an easier way, what the hell is this

    if vector_convert_to_srgb:
        compare_value = linear_to_srgb(compare_value, False)

    indexes = []
    if is_verbose_mode_enabled():
        
        print(f"""Get filtered indexes with settings:
{condition} to {compare_value}, 
case sensitive {case_sensitive_string}
convert compare value to srgb {vector_convert_to_srgb}""")
        if vector_convert_to_srgb:
            srgbs = [linear_to_srgb(i, return_float=False) for i in source_data]
            print(f"on dataset (int) (len {len(source_data)}) {srgbs}""")
        else:
            print(f"on dataset (float) (len {len(source_data)}) {source_data}""")

    #booleans
    if type(source_data[0]) is bool:
        for i, data in enumerate(source_data):
            if condition == "EQ" and data == compare_value:
                indexes.append(i)

            elif condition == "NEQ" and data != compare_value:
                indexes.append(i)

    # numeric values & floats invididual vals
    elif type(source_data[0]) in [int, float, np.int32, np.float, np.float64]:
        for i, data in enumerate(source_data):
            if vector_convert_to_srgb:
                data = linear_to_srgb(data, False)
            if condition == "EQ" and data == compare_value: #equal
                indexes.append(i)

            elif condition == "NEQ" and data != compare_value: # not equal
                indexes.append(i)

            elif condition == "EQORGR" and data >= compare_value: # >=
                indexes.append(i)

            elif condition == "EQORLS" and data <= compare_value: # <=
                indexes.append(i)

            elif condition == "GR" and data > compare_value: # >
                indexes.append(i)

            elif condition == "LS" and data < compare_value: # <
                indexes.append(i)
    
    # strings
    elif type(source_data[0]) == str:
        for i, data in enumerate(source_data):
        
            # case sensitive toggle
            if not case_sensitive_string:
                value = data.upper()
                cmp = compare_value.upper()
            else:
                value = data
                cmp = compare_value

            if condition == "EQ" and value == cmp: #equal
                indexes.append(i)

            elif condition == "NEQ" and value != cmp: #not equal
                indexes.append(i)
            
            elif condition == "CONTAINS" and cmp in value: # contains
                indexes.append(i)
            
            elif condition == "STARTS_WITH" and value.startswith(cmp): #equal
                indexes.append(i)

            elif condition == "ENDS_WITH" and value.endswitch(cmp): #endswith
                indexes.append(i)
    else:
        raise etc.GenericFunctionParameterError("get_filtered_indexes_by_condition", f"Unsupported input data type: {type(source_data[0])}")

    if is_verbose_mode_enabled():
        print(f"Filtered indexes: {indexes}")
    return indexes

def get_domain_attribute_values(obj, domain, attribute_name):
    """Gets values of attribute stored in domain like: edges[0].use_sharp 

    Args:
        obj (Reference): 3D Object Reference
        domain (str): Name of the domain: POINT EDGE FACE CORNER
        attribute_name (str): Name of the attribute to set eg. use_sharp

    Returns:
        list: A list of values in that attribute. The type of values in list is variable.
    """
    try:
        if domain== "POINT":
            print(f"getting {attribute_name} 0: {getattr(obj.data.vertices[0], attribute_name)}")
            return [getattr(v, attribute_name) for v in obj.data.vertices]
        elif domain == "EDGE":
            return  [getattr(v, attribute_name) for v in obj.data.edges]
        elif domain == "FACE":
            return [getattr(v, attribute_name) for v in obj.data.polygons]
        elif domain == "CORNER":
            return [getattr(v, attribute_name) for v in obj.data.loops]
    except Exception as e:
        raise etc.MeshDataReadException("get_domain_attribute_values", f"Failed to get {attribute_name} from {domain} \n {e}")

def get_mesh_data(obj, data_type, source_domain, **kwargs):
    """Gets all selected data from mesh.

    Args:
        obj (Reference): Object Reference
        data_type (str): The data type to fetch. See data.object_data_sources
        source_domain (str): The domain to take this data from

        kwargs: (if applicable)
        * vg_index              index of vertex group [id]
        * sk_index              index of shape key [id]
        * vg_offset_index       index of vertex group and the vertex group to offset from [id1, id2]
        * fm_index              face map index
        * sel_mat               selected material
        * mat_index             material index
        * uvmap_index           uvmap index

    Raises:
        etc.MeshDataReadException: on failure if selected data type does not exist

    Returns:
        list: _All values. Might conatain tuples or multi level lists.
    """

    
    
    if is_verbose_mode_enabled():
        print(f"get_mesh_data_kwargs: {kwargs}")
        print(f"Reading {data_type} mesh data on {source_domain}...")

    # DOMAIN INDEX
    if data_type == "INDEX":

        if source_domain == "POINT":
            return [i for i, vert in enumerate(obj.data.vertices)]

        elif source_domain == "EDGE":
            return [i for i, edge in enumerate(obj.data.edges)]

        elif source_domain == "FACE":
            return [i for i, face in enumerate(obj.data.polygons)]

        elif source_domain == "CORNER":
            return [i for i, corner in enumerate(obj.data.loops)]
        
    # VISIBILITY IN EDIT MODE
    elif data_type == "VISIBLE":
        return [not val for val in get_domain_attribute_values(obj, source_domain, "hide")]

    # SELECTED
    elif data_type == "SELECTED":
        return get_domain_attribute_values(obj, source_domain, "select")

    # NOT SELECTED
    elif data_type == "NOT_SELECTED":
        return [not val for val in get_domain_attribute_values(obj, source_domain, "select")]
 
    # POSITION
    elif data_type == "POSITION":
        if source_domain == 'POINT':
            return get_domain_attribute_values(obj, source_domain, "co")
        
        elif source_domain == 'EDGE':
            pairs = get_domain_attribute_values(obj, source_domain, "vertices")
            storage = []
            for i, vert_pair in enumerate(pairs):
                pos_0 = obj.data.vertices[vert_pair[0]].co
                pos_1 = obj.data.vertices[vert_pair[1]].co
                edge_pos = (pos_0 + pos_1)/2
                storage.append(edge_pos)
            return storage

        elif source_domain == 'FACE':
            return [val for val in get_domain_attribute_values(obj, source_domain, "center")]

    # NORMALS
    elif data_type == "NORMAL":
        if source_domain == "POINT":
            return [vec.vector for vec in obj.data.vertex_normals]
            
        elif source_domain == "FACE":
            return [vec.vector for vec in obj.data.polygon_normals]
    
    # CUSTOM SPLIT NORMALS
    elif data_type == "SPLIT_NORMALS":
            return get_domain_attribute_values(obj, source_domain, "normal")

    # VERTEX MESH ATTRIBUTES START
    # -----------------------------

    # VERTEX MEAN BEVEL
    elif data_type == "VERT_MEAN_BEVEL":
        
        if hasattr(obj.data.vertices, "bevel_weight"):
            return get_domain_attribute_values(obj, source_domain, "bevel_weight")
        else:
            if not "bevel_weight_vert" in obj.data.attributes:
                return [0.0] * len(obj.data.vertices)
            else:
                return [bevel.value for bevel in obj.data.attributes["bevel_weight_vert"].data]


    # VERTEX MEAN CREASE
    elif data_type == "VERT_MEAN_CREASE":
        if bpy.app.version < (4,0):
            if not len(obj.data.vertex_creases):
                return [0.0] * len(obj.data.vertices)
            else:
                return [crease.value for crease in obj.data.vertex_creases[0].data]
        else:
            if not "vertex_creases" in obj.data.attributes:
                return [0.0] * len(obj.data.vertices)
            else:
                return [crease.value for crease in obj.data.attributes["vertex_creases"].data.values()]
    
    # SCULPT MODE MASK ON VERTEX
    elif data_type == "SCULPT_MODE_MASK":
        if not len(obj.data.vertex_paint_masks):
            return [0.0] * len(obj.data.vertices)
        else:
            return [mask.value for mask in obj.data.vertex_paint_masks[0].data]
        
    # VERT_IS_IN_VERTEX_GROUP
    elif data_type == "VERT_IS_IN_VERTEX_GROUP":        
        vg = obj.vertex_groups[int(kwargs['vg_index'])]
        data = []

        for vert in obj.data.vertices:
            b_is_in_group = False
            for group in vert.groups:
                if group.group == int(kwargs['vg_index']):
                    b_is_in_group = True
                    break
            data.append(b_is_in_group)
        return data
    
    # VERTEX GROUP VALUE
    elif data_type == "VERT_FROM_VERTEX_GROUP" :        
        vg = obj.vertex_groups[int(kwargs['vg_index'])]
        data = []

        for vert in obj.data.vertices:
            weight = 0.0
            
            for group in vert.groups:
                if group.group == int(kwargs['vg_index']):
                    weight = group.weight
                    break
            data.append(weight)

        return data

    # VERT_SHAPE_KEY_POSITION
    elif data_type == "VERT_SHAPE_KEY_POSITION":
        sk = obj.data.shape_keys.key_blocks[int(kwargs['sk_index'])]
        return [vert.co for vert in sk.data]

    # VERT SHAPE KEY OFFSET
    elif data_type == "VERT_SHAPE_KEY_POSITION_OFFSET":
        sk = obj.data.shape_keys.key_blocks[int(kwargs['sk_index'])]
        offset_from = [vert_shape.co for vert_shape in sk.data]

        offset_sk = obj.data.shape_keys.key_blocks[int(kwargs['sk_offset_index'])]
        offset_to = [vert_shape.co for vert_shape in offset_sk.data]
        
        for vert in obj.data.vertices:
            offset_from[vert.index] = offset_to[vert.index] - offset_from[vert.index]
        return offset_from


    # EDGE MESH ATTRIBUTES START
    # -----------------------------

    # EDGE SEAM
    elif data_type == "EDGE_SEAM":
        return get_domain_attribute_values(obj, source_domain, "use_seam") 
        
    # EDGE BEVEL WEIGHT
    elif data_type == "EDGE_BEVEL_WEIGHT":
 
        if hasattr(obj.data.vertices, "bevel_weight"):
            return get_domain_attribute_values(obj, source_domain, "bevel_weight")
        else:
            if not "bevel_weight_edge" in obj.data.attributes:
                return [0.0] * len(obj.data.edges)
            else:
                return [bevel.value for bevel in obj.data.attributes["bevel_weight_edge"].data]
    
    # EDGE CREASE
    elif data_type == "EDGE_CREASE":
        if bpy.app.version < (4,0):
            return get_domain_attribute_values(obj, source_domain, "crease") 
        else:
            if not "edge_creases" in obj.data.attributes:
                return [0.0] * len(obj.data.edges)
            else:
                return [crease.value for crease in obj.data.attributes["edge_creases"].data.values()]
        
    # EDGE SHARP
    elif data_type == "EDGE_SHARP":
        if hasattr(obj.data.edges, "use_sharp"):
            return get_domain_attribute_values(obj, source_domain, "use_sharp")
        elif hasattr(obj.data.edges, "use_edge_sharp"):
            return get_domain_attribute_values(obj, source_domain, "use_edge_sharp")
        else:
            if not "sharp_edge" in obj.data.attributes:
                return [False] * len(obj.data.edges)
            else:
                return [sharp.value for sharp in obj.data.attributes["sharp_edge"].data]
        
        
    # EDGE FREESTYLE MARK
    elif data_type == "EDGE_FREESTYLE_MARK":
        return get_domain_attribute_values(obj, source_domain, "use_freestyle_mark") 
        
    # EDGE IS LOOSE
    elif data_type == "EDGE_IS_LOOSE":
        return get_domain_attribute_values(obj, source_domain, "is_loose") 
        
    # EDGE_VERTICES
    elif data_type == "EDGE_VERTICES":
        return get_domain_attribute_values(obj, source_domain, "vertices") 
        
    # FACE MESH ATTRIBUTES START
    # -----------------------------

    # SCULPT MODE FACE SETS IDS
    elif data_type == "SCULPT_MODE_FACE_SETS":
        if bpy.app.version < (4,0):
            # case: no face sets
            if ".sculpt_face_set" not in obj.data.polygon_layers_int:
                return [0] * len(obj.data.polygons)
            else:
                return [face.value for face in obj.data.polygon_layers_int['.sculpt_face_set'].data]
        else:
            if not ".sculpt_face_set" in obj.data.attributes:
                return [0] * len(obj.data.polygons)
            else:
                return [faceset.value for faceset in obj.data.attributes[".sculpt_face_set"].data]
        
    # FACE_AREA
    elif data_type == "FACE_AREA":
        return get_domain_attribute_values(obj, source_domain, "area") 
    
    # FACE IS SMOOTH SHADED
    elif data_type == "FACE_USE_SMOOTH":
        if not hasattr(obj.data.polygons[0], "use_smooth"):
            return get_domain_attribute_values(obj, source_domain, "use_smooth") 
        else: # futureproofing
            if not "sharp_face" in obj.data.attributes:
                return [False] * len(obj.data.polygons)
            else:
                return [faceset.value for faceset in obj.data.attributes["sharp_face"].data]

    # FACE MATERIAL INDEX
    elif data_type == "FACE_MATERIAL_INDEX":
        if not hasattr(obj.data.polygons[0], "material_index"):
            return get_domain_attribute_values(obj, source_domain, "material_index") 
        else: # futureproofing
            if not "material_index" in obj.data.attributes:
                return [0] * len(obj.data.polygons)
            else:
                return [faceset.value for faceset in obj.data.attributes["material_index"].data]
        
    # FACE VERTS
    elif data_type == "FACE_VERTS":
        return [f.vertices for f in obj.data.polygons]
        
    # FACE_CORNER_INDEXES
    elif data_type == "FACE_CORNER_INDEXES":
        return [f.loop_indices for f in obj.data.polygons]
    
    # FACE CORNER COUNT
    elif data_type == "FACE_CORNER_TOTAL":
        return get_domain_attribute_values(obj, source_domain, "loop_total") 

    # FACE CORNER START INDEX
    elif data_type == "FACE_CORNER_START_INDEX":
        return get_domain_attribute_values(obj, source_domain, "loop_start") 

    # FACE_FROM_FACE_MAP
    elif data_type == "FACE_FROM_FACE_MAP":
        # WARN: IF NO FACE MAP WAS SET THEN obj.data.face_maps len = 0, even if it was created in the properties panel...
        if len(obj.data.face_maps):
            # print(kwargs['fm_index'])
            # print([obj.data.face_maps[0].data[i].value for i, f in enumerate(obj.data.polygons)])
            return [obj.data.face_maps[0].data[i].value == int(kwargs['fm_index']) for i, f in enumerate(obj.data.polygons)]
        else:
            return [False] * len(obj.data.polygons)

    # FACE MAP INDEX
    elif data_type == "FACE_MAP_INDEX":
        if len(obj.data.face_maps):
            return [obj.data.face_maps[0].data[i].value for i, f in enumerate(obj.data.polygons)]
        else:
            return [-1] * len(obj.data.polygons)

    # FACE MATERIAL INDEX
    elif data_type == "FACE_IS_MATERIAL_ASSIGNED":
        # print(bpy.data.materials[int(kwargs['sel_mat'])])
        # print([obj.material_slots[f.material_index].material for f in obj.data.polygons])
        if len(obj.material_slots):
            return [obj.material_slots[f.material_index].material == bpy.data.materials[int(kwargs['sel_mat'])] for f in obj.data.polygons]
        else:
            return [False] * len(obj.data.polygons)

    #"FACE_IS_MATERIAL_SLOT_ASSIGNED",
    elif data_type == "FACE_IS_MATERIAL_SLOT_ASSIGNED":
        if len(obj.material_slots):
            return [f.material_index == int(kwargs['mat_index']) for f in obj.data.polygons]
        else:
            return [False] * len(obj.data.polygons)

    # FACE CORNER MESH ATTRIBUTES START
    # -----------------------------

    # TANGENT
    elif data_type == "CORNER_TANGENT":
        return get_domain_attribute_values(obj, source_domain, "tangent") 
        
    # BITANGENT
    elif data_type == "CORNER_BITANGENT":
        return get_domain_attribute_values(obj, source_domain, "bitangent") 
    
    # BITANGENT SIGN
    elif data_type == "CORNER_BITANGENT_SIGN":
        return get_domain_attribute_values(obj, source_domain, "bitangent_sign") 
        
    # EDGE INDEX
    elif data_type == "CORNER_EDGE_INDEX":
        return get_domain_attribute_values(obj, source_domain, "edge_index") 
        
    # VERTEX INDEX
    elif data_type == "CORNER_VERTEX_INDEX":
        return get_domain_attribute_values(obj, source_domain, "vertex_index") 
    
    # UVMAP
    elif data_type == "UVMAP":
        return [map.uv for map in obj.data.uv_layers[int(kwargs['uvmap_index'])].data]
    

    # -----------------------------
    # SPECIAL ATTRIBS START

    # SELECTED VERTS IN UV EDITOR
    elif data_type == "SELECTED_VERTICES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name
        attribute_name = f".vs.{uvmap_name}"
        if attribute_name in obj.data.attributes:
            return [es.value for es in obj.data.attributes[attribute_name].data]
        else:
            return [False] * len(obj.data.loops)
    
    # SELECTED EDGES IN UV EDITOR
    elif data_type == "SELECTED_EDGES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name
        attribute_name = f".es.{uvmap_name}"
        if attribute_name in obj.data.attributes:
            return [es.value for es in obj.data.attributes[attribute_name].data]
        else:
            return [False] * len(obj.data.loops)

    # SELECTED EDGES IN UV EDITOR
    elif data_type == "PINNED_VERTICES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name
        attribute_name = f".pn.{uvmap_name}"
        if attribute_name in obj.data.attributes:
            return [es.value for es in obj.data.attributes[attribute_name].data]
        else:
            return [False] * len(obj.data.loops)
    
    else:
        raise etc.MeshDataReadException("get_mesh_data", f"Invalid domain data type ({data_type}) or this data is not available on this domain ({source_domain})")

# set

def set_domain_attribute_values(obj, attribute_name:str, domain:str, values: list):
    """Sets values of attribute stored in domain like: edges[0].use_sharp 

    Args:
        obj (Reference): 3D Object Reference
        attribute_name (str): Name of the attribute
        domain (str): Attribute Domain
        values (list): Values to set 
    """

    if domain == 'POINT':
        for i, vert in enumerate(obj.data.vertices):
            setattr(vert, attribute_name, values[i])
    elif domain == 'EDGE':
        for i, edge in enumerate(obj.data.edges):
            setattr(edge, attribute_name, values[i])
    elif domain == 'FACE':
        for i, face in enumerate(obj.data.polygons):
            setattr(face, attribute_name, values[i])
    elif domain == 'CORNER':
        for i, loop in enumerate(obj.data.loops):
            setattr(loop, attribute_name, values[i])

def set_selection_or_visibility_of_mesh_domain(obj, domain, indexes, state = True, selection = True):
    """Sets the selection or visibility in edit mode.
    Those require setting the state of faces, edges and vertices separately, hence the separate function.

    Args:
        obj (Reference ): 3D Object Reference
        domain (str): Domain - POINT EDGE FACE CORNER
        indexes (list): Domain indexes to set the state
        state (bool, optional): The state of visibility or selection. Defaults to True.
        selection (bool, optional): Whether toggle selection or visibility. Defaults to True.

    Raises:
        Exception: On failure, re-raises the exception and clears bmesh
    """
    if is_verbose_mode_enabled():
        print(f"Setting sel/vis {selection} to state  {state} on {domain}, \ndataset {indexes}")

    bm = bmesh.new()
    bm.from_mesh(obj.data)
    bm.verts.ensure_lookup_table()
    bm.edges.ensure_lookup_table()
    bm.faces.ensure_lookup_table()
    if domain != 'CORNER':
        try:
            if domain == 'POINT':
                for vertindex in indexes:
                    if selection:
                        bm.verts[vertindex].select = state
                    else:
                        bm.verts[vertindex].hide = state

                    for edge in bm.verts[vertindex].link_edges:
                        if state == selection:
                            if all(vert.index in indexes for vert in edge.verts):
                                if selection:
                                    edge.select = state
                                else:
                                    edge.hide = state
                        else:
                            if any(vert.index in indexes for vert in edge.verts):
                                if selection:
                                    edge.select = state
                                else:
                                    edge.hide = state

                    for face in bm.verts[vertindex].link_faces:
                        if state == selection:
                            if all(vert.index in indexes for vert in face.verts):
                                if selection:
                                    face.select = state
                                else:
                                    face.hide = state
                        else:
                            if any(vert.index in indexes for vert in face.verts):
                                if selection:
                                    face.select = state
                                else:
                                    face.hide = state

            elif domain == 'EDGE':
                for edgeindex in indexes:
                    if selection:
                        bm.edges[edgeindex].select = state
                    else:
                        bm.edges[edgeindex].hide = state

                    for vert in bm.edges[edgeindex].verts:
                        if selection:
                            vert.select = state
                        else:
                            vert.hide = state
                
                    for face in bm.edges[edgeindex].link_faces:
                        if state == selection:
                            if all(edge.index in indexes for edge in face.edges):
                                if selection:
                                    face.select = state
                                else:
                                    face.hide = state
                        else:
                            if any(edge.index in indexes for edge in face.edges):
                                if selection:
                                    face.select = state
                                else:
                                    face.hide = state
                    
            elif domain == 'FACE':
                for faceindex in indexes:
                    if selection:
                        bm.faces[faceindex].select = state
                    else:
                        bm.faces[faceindex].hide = state

                    for vert in bm.faces[faceindex].verts:
                        if selection:
                            vert.select = state
                        else:
                            vert.hide = state
                    
                    for edge in bm.faces[faceindex].edges:
                        if selection:
                            edge.select = state
                        else:
                            edge.hide = state
            
            bm.to_mesh(obj.data)
            bm.free()
        except Exception as e:
            # clear bmesh on exception to avoid extra problems
            bm.to_mesh(obj.data)
            bm.free()
            raise Exception(e)

    else:
        if etc.get_preferences_attrib("select_attribute_precise_facecorners"):
            edge_indexes_to_select = [] 
            
            for cornerindex in indexes:
                loop = obj.data.loops[cornerindex]

                # get the face index that has this corner
                faceindex = -1
                for face in bm.faces:
                    if cornerindex in [loop.index for loop in face.loops]:
                        faceindex = face.index
                
                # get edges that are connected to vertex assinged to this corner
                edges = bm.verts[loop.vertex_index].link_edges
                if is_verbose_mode_enabled():
                    print(f"loop {cornerindex} has edges {[edge.index for edge in edges]}")
                    print(f"loop {cornerindex} has a face {faceindex}, with edges {[edge.index for edge in bm.faces[faceindex].edges]}")
                
                # get edges that are in face index of this corner
                for edge in edges:
                    if edge in bm.faces[faceindex].edges:
                        edge_indexes_to_select.append(edge.index)
            
            bm.free()
            if is_verbose_mode_enabled():
                print(f"Filtered edges of the corner are {edge_indexes_to_select}")
            set_selection_or_visibility_of_mesh_domain(obj, 'EDGE', edge_indexes_to_select, state, selection)
        
        # The fast method
        elif len(indexes):
            mesh_selected_modes = bpy.context.scene.tool_settings.mesh_select_mode

            storage = np.zeros(len(obj.data.loops), dtype=int)

            # User is in edit mode with edge or face selection mode
            if mesh_selected_modes[1] or mesh_selected_modes[2]:
                obj.data.loops.foreach_get('edge_index', storage)
                storage = np.take(storage, indexes)
                set_selection_or_visibility_of_mesh_domain(obj, 'EDGE', storage, state, selection)

            # Any other mode 
            else:
                obj.data.loops.foreach_get('vertex_index', storage)
                storage = np.take(storage, indexes)
                set_selection_or_visibility_of_mesh_domain(obj, 'POINT', storage, state, selection)
                
def set_mesh_data(obj, data_target:str , src_attrib, new_data_name = "", overwrite = False, **kwargs):
    """Sets mesh data from selected attribute

    Args:
        obj (Reference): 3D Object Reference
        data_target (str): See data.object_data_targets
        src_attrib (Reference): Attribute reference
        new_data_name (str): The name of new shape key, vertex group etc.
        overwrite (boolean): if name of the shape key/vertex group exists, replace the data
        
        kwargs: (If applicable)
        * enable_auto_smooth        bool
        * apply_to_first_shape_key  bool
        * to_vgindex_weight         float
        * to_vgindex_weight_mode    enum - STATIC, ATTRIBUTE
        * to_vgindex_src_attrib     attribute reference
        * uvmap_index               integer
        * invert_sculpt_mask        boolean, 1-clamped sculpt mask val
        * expand_sculpt_mask_mode   enum REPLACE EXPAND SUBTRACT
        * normalize_mask            boolean
        * raw_data                  list, if attribute is none this can set the values directly


    Raises:
        etc.MeshDataWriteException: On failure if selected data target is not supported

    Returns:
        Nothing
    """
    
    def foreach_get_mesh_data_value(data, prop):
        sample = getattr(data[0], prop)
        if type(sample) in [tuple, list]:
            storage_multi = len(sample)
        else:
            storage_multi = 1
        storage = [None] * len(data) * storage_multi
        data.foreach_get(prop, storage)
        return storage
    
    def foreach_set_mesh_data_value(data, prop, values):
        data.foreach_set(prop, values)
        return True

    if 'raw_data' in kwargs:
        a_vals = kwargs['raw_data']
    else:
        a_vals = get_attribute_values(src_attrib, obj)
    if is_verbose_mode_enabled():
        print(f"Setting mesh data {data_target} from {src_attrib}, \nvalues: {a_vals}, \nkwargs: {kwargs}, \ncustom name: {new_data_name}")
    
    if 'raw_data' not in kwargs:
        src_attrib_name = src_attrib.name # for setting active attribute ONLY

    # QUICK BOOLEANS
    # -----------------------------

    # TO VISIBLE
    if data_target == "TO_VISIBLE":
        vis_indexes = [index for index, value in enumerate(a_vals) if value]
        set_selection_or_visibility_of_mesh_domain(obj, src_attrib.domain, vis_indexes, False, selection=False)

    # TO HIDDEN
    elif data_target == "TO_HIDDEN":
        hid_indexes = [index for index, value in enumerate(a_vals) if value]
        set_selection_or_visibility_of_mesh_domain(obj, src_attrib.domain, hid_indexes, True, selection=False)

    # TO SELECTED
    elif data_target == "TO_SELECTED":
        sel_indexes = [index for index, value in enumerate(a_vals) if value]
        set_selection_or_visibility_of_mesh_domain(obj, src_attrib.domain, sel_indexes, True)

    # TO NOT SELECTED
    elif data_target == "TO_NOT_SELECTED":
         nsel_indexes = [index for index, value in enumerate(a_vals) if value]
         set_selection_or_visibility_of_mesh_domain(obj, src_attrib.domain, nsel_indexes, False)


    # VERTEX MESH DATA
    # -----------------------------

    # TO VERTEX GROUP INDEX
    elif data_target == "TO_VERTEX_GROUP_INDEX":
    
        # clamp to max index
        max_index_input = max(a_vals)
        max_index_target = len(obj.vertex_groups) - 1
        max_index = max(min([max_index_input, max_index_target]), 0)
        
        if kwargs["to_vgindex_weight_mode"] == 'STATIC':
            #lazy set the weight to static value
            for i, val in enumerate(a_vals):
                obj.vertex_groups[min([max_index, max(val,0)])].add([i], kwargs['to_vgindex_weight'], 'REPLACE')
        
        # or use attrib
        elif kwargs["to_vgindex_weight_mode"] == 'ATTRIBUTE':
            for i, val in enumerate(a_vals):
                
                obj.vertex_groups[min([max_index, max(val,0)])].add([i], kwargs['to_vgindex_src_attrib'].data[i].value, 'REPLACE')

    # TO SCULPT MODE MASK
    elif data_target == "TO_SCULPT_MODE_MASK":

        # case: no mask layer, user never used mask on this mesh
        if not len(obj.data.vertex_paint_masks):
            # I have not found a way to create a mask layer without using bmesh, so here it goes
            bm = bmesh.new()
            bm.from_mesh(obj.data)
            bm.verts.layers.paint_mask.verify()
            bm.to_mesh(obj.data)
            bm.free()
            
            if 'raw_data' not in kwargs:
                src_attrib = obj.data.attributes[src_attrib_name] # !important
        
        if kwargs['invert_sculpt_mask']:
            for i in range(0, len(a_vals)):
                a_vals[i] = 1 - a_vals[i]

        if kwargs['expand_sculpt_mask_mode'] != 'REPLACE':
            storage = foreach_get_mesh_data_value(obj.data.vertex_paint_masks[0].data, 'value')

            if kwargs['expand_sculpt_mask_mode'] == 'EXPAND':
                for i in range(0, len(storage)):
                    a_vals[i] = storage[i] + a_vals[i] 
            elif kwargs['expand_sculpt_mask_mode'] == 'SUBTRACT':
                for i in range(0, len(storage)):
                    a_vals[i] = storage[i] - a_vals[i] 

        if kwargs['normalize_mask']:
            for i, val in enumerate(a_vals):
                a_vals[i] = min(max(val, 0.0), 1.0)

        
        foreach_set_mesh_data_value(obj.data.vertex_paint_masks[0].data, 'value', a_vals)

        
    # TO VERTEX GROUP
    elif data_target == "TO_VERTEX_GROUP":
        name = get_safe_attrib_name(obj, new_data_name, 'Group', check_attributes=True)
        if name in obj.vertex_groups and overwrite:
            vg = obj.vertex_groups[name]
        else:
            vg = obj.vertex_groups.new(name=name)

        for vert in obj.data.vertices:
            weight = a_vals[vert.index]
            vg.add([vert.index], weight, 'REPLACE')

    # TO POSITION
    elif data_target == "TO_POSITION":
        set_domain_attribute_values(obj, 'co', src_attrib.domain, a_vals) 

        # Apply to first shape key too, if enabled
        if hasattr(obj.data.shape_keys, 'key_blocks') and kwargs["apply_to_first_shape_key"]:
            sk = obj.data.shape_keys.key_blocks[obj.data.shape_keys.key_blocks.keys()[0]].data
            for i, val in enumerate(a_vals):
                sk[i].co = val

    # TO SHAPE KEY
    elif data_target == "TO_SHAPE_KEY":
        if new_data_name in obj.data.shape_keys.key_blocks and overwrite:
            sk = obj.data.shape_keys.key_blocks[new_data_name]
        else:
            sk = obj.shape_key_add(name=new_data_name)

        l = [[vec[0],vec[1],vec[2]] for vec in a_vals]
        for vert in obj.data.vertices:
            sk.data[vert.index].co = l[vert.index]

    # VERTEX & EDGE MESH DATA
    # -----------------------------

    # TO MEAN BEVEL WEIGHT
    elif data_target == "TO_MEAN_BEVEL_WEIGHT":
        if hasattr(obj.data.vertices, 'bevel_weight'): # Works for edges too, as the api change happened for both at once.
            set_domain_attribute_values(obj, 'bevel_weight', src_attrib.domain, a_vals) 
        else:
            if src_attrib.domain == 'POINT':
                if not "bevel_weight_vert" in obj.data.attributes:
                    obj.data.attributes.new("bevel_weight_vert", 'FLOAT', 'POINT')
                set_attribute_values(obj.data.attributes["bevel_weight_vert"], a_vals)

            elif src_attrib.domain == 'EDGE':
                if not "bevel_weight_edge" in obj.data.attributes:
                    obj.data.attributes.new("bevel_weight_edge", 'FLOAT', 'EDGE')
                set_attribute_values(obj.data.attributes["bevel_weight_edge"], a_vals)
        
    # TO MEAN CREASE
    elif data_target == "TO_MEAN_CREASE":
        if src_attrib.domain == 'POINT':
            if bpy.app.version < (4,0):
                
                # Create layer if it does not exist:
                if not len(obj.data.vertex_creases):
                    bm = bmesh.new()
                    bm.from_mesh(obj.data)
                    bm.verts.layers.crease.verify()
                    bm.to_mesh(obj.data)
                    bm.free()
                for i, val in enumerate(a_vals):
                    obj.data.vertex_creases[0].data[i].value = val
            else:
                if not "vertex_creases" in obj.data.attributes:
                    obj.data.attributes.new("vertex_creases", 'FLOAT', 'POINT')
                
                set_attribute_values(obj.data.attributes["vertex_creases"], a_vals)
                
        elif src_attrib.domain == 'EDGE':
            if bpy.app.version < (4,0):
                set_domain_attribute_values(obj, 'crease', src_attrib.domain, a_vals) 
            else:
                if not "edge_creases" in obj.data.attributes:
                    obj.data.attributes.new("edge_creases", 'FLOAT', 'EDGE')
                set_attribute_values(obj.data.attributes["edge_creases"], a_vals)
   
    # EDGE MESH DATA
    # -----------------------------

    # TO EDGE SEAM
    elif data_target == "TO_SEAM":
        set_domain_attribute_values(obj, 'use_seam', src_attrib.domain, a_vals) 

    # TO EDGE SHARP
    elif data_target == "TO_SHARP":
        if len(obj.data.edges):
            if hasattr(obj.data.edges[0], "use_sharp"):
                set_domain_attribute_values(obj, "use_sharp", src_attrib.domain, a_vals) 
            elif hasattr(obj.data.edges[0], "use_edge_sharp"):
                set_domain_attribute_values(obj, 'use_edge_sharp', src_attrib.domain, a_vals) 

    # TO FREESTYLE MARK
    elif data_target == "TO_FREESTYLE_MARK":
        set_domain_attribute_values(obj, 'use_freestyle_mark', src_attrib.domain, a_vals) 

    # FACE MESH DATA
    # -----------------------------

    # TO FACE MAP
    elif data_target == "TO_FACE_MAP":
        fm_name = "Face Map" if new_data_name == '' else new_data_name
        
        if fm_name in obj.face_maps and overwrite:
            fm = obj.face_maps[fm_name].index
        else:
            fm = obj.face_maps.new(name=fm_name)
        
        # create layer
        bm = bmesh.new()
        bm.from_mesh(obj.data)
        bm.faces.layers.face_map.verify()
        bm.to_mesh(obj.data)
        bm.free()

        # Set face map index to selected polygons in attribute (True)
        for i, val in enumerate(a_vals):
            if val:
                obj.data.face_maps[0].data[i].value = fm.index

    # TO SHADE SMOOTH
    elif data_target == "TO_FACE_SHADE_SMOOTH":
        set_domain_attribute_values(obj, 'use_smooth', src_attrib.domain, a_vals) 
    
    # TO SCULPT MODE FACE SETS
    elif data_target == "TO_SCULPT_MODE_FACE_SETS":

        if etc.get_blender_support(minver_unsupported=(4,0,0)):
            # case: no face sets
            if ".sculpt_face_set" not in obj.data.polygon_layers_int:
                obj.data.polygon_layers_int.new(name=".sculpt_face_set" )

            for i, val in enumerate(a_vals):
                obj.data.polygon_layers_int['.sculpt_face_set'].data[i].value = val
        else:
            if not '.sculpt_face_set' in obj.data.attributes:
                obj.data.attributes.new('.sculpt_face_set', 'INT', 'FACE')
            
            set_attribute_values(obj.data.attributes['.sculpt_face_set'], a_vals)

    
    # TO MATERIAL INDEX
    elif data_target == "TO_MATERIAL_SLOT_INDEX":
        if len(obj.data.polygons):
            max_index = max((len(obj.material_slots)-1), 0)

            if hasattr(obj.data.polygons[0], 'material_index'):
                if max_index > 0:
                    set_domain_attribute_values(obj, 'material_index', src_attrib.domain, a_vals) 

            else: # futureproofing
                if not 'material_index' in obj.data.attributes:
                    obj.data.attributes.new('material_index', 'INT', 'FACE')
                set_attribute_values(obj.data.attributes['material_index'], a_vals)
    
    # TO FACE MAP INDEX
    elif data_target == "TO_FACE_MAP_INDEX":
        for i, val in enumerate(a_vals):
            # limit the value
            val = max(0, min(val, len(obj.face_maps)-1))
            obj.data.face_maps[0].data[i].value = val

    # FACE CORNER MESH DATA
    # -----------------------------

    # TO SPLIT NORMALS
    elif data_target == 'TO_SPLIT_NORMALS':
        obj.data.use_auto_smooth = kwargs['enable_auto_smooth']
        if src_attrib.domain == 'POINT':
            obj.data.normals_split_custom_set_from_vertices([[vec[0],vec[1],vec[2]] for vec in a_vals])
        elif src_attrib.domain == 'CORNER':
            obj.data.normals_split_custom_set([[vec[0],vec[1],vec[2]] for vec in a_vals])
    
    # TO UV MAP
    elif data_target == "TO_UVMAP":
        if not (new_data_name in obj.data.uv_layers and overwrite):
            obj.data.uv_layers.new(name=new_data_name)

        for i, val in enumerate(a_vals):
            obj.data.uv_layers[int(kwargs['uvmap_index'])].data[i].uv = (val[0], val[1])

    # UV EDITOR SPECIALS
    # -----------------------------

    # TO SELECTED VERTICES IN UV EDITOR
    elif data_target == "TO_SELECTED_VERTICES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name
        attribute_name = f'.vs.{uvmap_name}'

        if not attribute_name in obj.data.attributes:
            obj.data.attributes.new(attribute_name, 'BOOLEAN', 'CORNER')

        for i, val in enumerate(a_vals):
            obj.data.attributes[attribute_name].data[i].value = val

    # TO SELECTED EDGES IN UV EDITOR
    elif data_target == "TO_SELECTED_EDGES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name
        attribute_name = f'.es.{uvmap_name}'

        if not attribute_name in obj.data.attributes:
            obj.data.attributes.new(attribute_name, 'BOOLEAN', 'CORNER')

        for i, val in enumerate(a_vals):
            obj.data.attributes[attribute_name].data[i].value = val

    # TO PINNED VERTICES IN UV EDITOR
    elif data_target == "TO_PINNED_VERTICES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name
        attribute_name = f'.pn.{uvmap_name}'

        if not attribute_name in obj.data.attributes:
            obj.data.attributes.new(attribute_name, 'BOOLEAN', 'CORNER')

        for i, val in enumerate(a_vals):
            obj.data.attributes[attribute_name].data[i].value = val

    # NONE OF ABOVE
    # -----------------------------
    else:
        raise etc.MeshDataWriteException("set_mesh_data", f"Can't find {data_target} to set")
          
def get_all_mesh_data_indexes_of_type(obj,data_type):
    """Gets all indexes of iterable mesh data. Used in batch converting of attributes.

    * Vertex Groups
    * Shape Keys
    * Face Maps
    * Material Slots

    Args:
        obj (Reference): 3D Object Reference
        data_type (str): Namedtuple entry names, see data.object_data_sources

    Returns:
        list: of all indexes
    """

    if data_type in ["VERT_IS_IN_VERTEX_GROUP", "VERT_FROM_VERTEX_GROUP"]:   
        return [vg.index for vg in obj.vertex_groups]     

    elif data_type in ["VERT_SHAPE_KEY_POSITION" , "VERT_SHAPE_KEY_POSITION_OFFSET"]:
        return [i for i, sk in enumerate(obj.data.shape_keys.key_blocks)]

    elif data_type == "FACE_FROM_FACE_MAP":
        return list(set([obj.data.face_maps[0].data[i].value  for i, f in enumerate(obj.data.polygons)]))

    elif data_type in ["FACE_IS_MATERIAL_SLOT_ASSIGNED"]:
        return [i for i, mat_slot in enumerate(obj.material_slots)]

    elif data_type in ["FACE_IS_MATERIAL_ASSIGNED"]:
        mats = list(set([mat_slot.material for mat_slot in obj.material_slots if mat_slot.material is not None]))
        return [list(bpy.data.materials).index(mat) for mat in mats]
    
    elif data_type in ["SELECTED_VERTICES_IN_UV_EDITOR", "SELECTED_EDGES_IN_UV_EDITOR", "PINNED_VERTICES_IN_UV_EDITOR", 'UVMAP']:
        return [i for i, uv in enumerate(obj.data.uv_layers)]
    
    else:
        raise etc.GenericFunctionParameterError("get_all_mesh_data_indexes_of_type", f"Data type unsupported?: {data_type}")


# String Getters
# ------------------------------------------

def get_friendly_domain_name(domain_name_raw, plural=False, short=False):
    """Converts internal domain name to friendly name to be used in UI
    eg. CORNER to Face Corners

    Args:
        domain_name_raw (str): Domain name
        plural (bool, optional): Return plural string. Defaults to False.

    Returns:
        str: Friendly string
    """
    if short:
        return static_data.attribute_domains[domain_name_raw].friendly_name_short
    elif domain_name_raw == 'POINT':
        return "Vertex" if not plural else "Vertices"
    elif domain_name_raw == 'CORNER':
        return "Face Corner" if not plural else "Face Corners"
    else:
        return domain_name_raw.lower().capitalize() if not plural else domain_name_raw.lower().capitalize() + "s"

def get_friendly_data_type_name(data_type_raw):
    """Gets friendly name for attribute data types, to use it in GUI
    eg. INT8 -> 8-bit Integer. See data.attribute_data_types
    Args:
        data_type_raw (str): Data type

    Returns:
        str: Friendly string
    """
    if data_type_raw in static_data.attribute_data_types:
        return static_data.attribute_data_types[data_type_raw].friendly_name 
    else:
        return data_type_raw

def get_friendly_name_from_enum_function(context, enum_function, element:str):
    """Gets the Title from enum tuple

    Args:
        context (ref): Context Reference
        enum_function (function): The function that will return enum entries list
        element (str): The element id, aka first element in enum element tuple

    Returns:
        str: Title string, aka second element in enum element tuple
    """
    en = enum_function(context)
    for e in en:
        if e[0] == element:
            return e[1]
    else:
        return None


# Data enums
# --------------------------------------------

# individual mesh data enums

def get_face_maps_enum(self, context):
    """Gets all face maps as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []
    obj = bpy.context.active_object

    # case: no data
    if not hasattr(obj, 'face_maps') or not len(obj.face_maps):
        return [("NULL", "[!] No face maps", "")]


    for face_map in obj.face_maps:
        items.append((str(face_map.index), face_map.name, f"Use {face_map.name} face map "))

    return items

def get_material_slots_enum(self, context):
    """Gets all material slots in active object as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """
    items = []
    obj = bpy.context.active_object

    # case: no data
    if not len(obj.material_slots):
        return [("NULL", "[!] No material slots", "")]

    for i, material_slot in enumerate(obj.material_slots):
        if material_slot is not None:
            material_slot_name = f"{str(i)}. {material_slot.name if material_slot.name != '' else 'Empty Slot'}"
            items.append((str(i), material_slot_name, f"Use {material_slot_name} material slot"))

    return items

def get_materials_enum(self, context):
    """Gets all materials stored in blend file as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []

    # case: no data
    if not len(bpy.data.materials):
        return [("NULL", "[!] No materials", "")]


    for i, material in enumerate(bpy.data.materials):
        if material is not None:
            items.append((str(i), material.name, f"Use {material.name} material"))

    return items

def get_vertex_groups_enum(self, context):
    """Gets all vertex groups of active object as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []
    obj = bpy.context.active_object

    # case: no data
    if not len(obj.vertex_groups):
        return [("NULL", "[!] No Vertex Groups", "")]

    for vg in obj.vertex_groups:
        items.append((str(vg.index), vg.name, f"Use {vg.name} vertex group"))

    return items

def get_shape_keys_enum(self, context):
    """Gets all shape keys of active object as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []
    obj = bpy.context.active_object

    # case: no data
    if obj.data.shape_keys is None:
        return [("NULL", "[!] No Shape Keys", "")]

    for i, sk in enumerate(obj.data.shape_keys.key_blocks):
        items.append((str(i), sk.name, f"Use {sk.name} shape key"))

    return items

def get_uvmaps_enum(self, context):
    """Gets all UVMaps of active object as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []
    obj = context.active_object

    # case: no data
    if not len(obj.data.uv_layers):
        return [("NULL", "NO UVMAPS", "")]


    for i, uvmap in enumerate(obj.data.uv_layers):
        items.append((str(i), uvmap.name, f"Use {uvmap.name} UVMap"))

    return items

# extra gui enums

def get_supported_domains_for_selected_mesh_data_source_enum_entry(self, context):
    """Gets aa list of compatible domains from enum selection in self.domain_data_type, for reading or writing mesh data from object

    Example being mean bevel that can be stored either in edges or vertices.

    [!] self object has to have domain_data_type enum enum property.

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    items = []
    domains_supported = static_data.object_data_sources[self.domain_data_type_enum].domains_supported

    
    if 'POINT' in domains_supported:
        items.append(("POINT", "Vertex", "Use vertex domain for data type"))
    if 'EDGE' in domains_supported:
        items.append(("EDGE", "Edge", "Use edge domain for data type"))
    if 'FACE' in domains_supported:
        items.append(("FACE", "Face", "Use face domain for data type"))
    if 'CORNER' in domains_supported:
        items.append(("CORNER", "Face Corner", "Use face corner domain for data type"))

    return items

def get_mesh_data_enum_entry_icon(data_item):
    """Sets the enum entry icon. Fallbacks to default icon if none is set.

    Args:
        data_item (Reference): Reference to namedtuple from data.object_data_sources or data.object_data_targets

    Returns:
        str: The icon string
    """
    # set the default icon based on supported domains, if none is set
    if data_item.icon == "":
        domains = data_item.domains_supported
        if len(domains) > 1:
            icon = "MATCUBE"
        elif domains[0] == "POINT":
            icon = "VERTEXSEL"
        elif domains[0] == "EDGE":
            icon = "EDGESEL"
        elif domains[0] == "FACE":
            icon = "FACESEL"
        elif domains[0] == "CORNER":
            icon = "SNAP_PERPENDICULAR"
    else:
        icon = data_item.icon
    return icon

def get_source_data_enum(self, context, include_separators=True):
    """Gets enum entries for source data selection to create an attribute from. Contains separators and newlines.

    Args:
        context (Reference): Blender context reference
        include_separators (bool): Whether to include newlines and separators for enum dropdown menu 

    Returns:
        list: List of tuples to be used as enum entries
    """
    e = []
    for i, item in enumerate(static_data.object_data_sources):
        if "INSERT_SEPARATOR" in item and include_separators:
            e.append((None))
        elif "INSERT_NEWLINE" in item and include_separators:
             e.append(("","","","",i))
        else:
            if static_data.object_data_sources[item] is None:
                continue
            minver = static_data.object_data_sources[item].min_blender_ver
            unsupported_from = static_data.object_data_sources[item].unsupported_from_blender_ver

            if etc.get_enhanced_enum_titles_enabled():
                name = static_data.object_data_sources[item].enum_gui_friendly_name
            else:
                name = static_data.object_data_sources[item].enum_gui_friendly_name_no_special_characters
            
            if etc.get_blender_support(minver, unsupported_from): 
                icon = get_mesh_data_enum_entry_icon(static_data.object_data_sources[item])
                e.append((item, name, static_data.object_data_sources[item].enum_gui_description, icon, i))
    return e

def get_source_data_enum_with_separators(self, context):
    return get_source_data_enum(self, context, include_separators=True)

def get_source_data_enum_without_separators(self, context):
    return get_source_data_enum(self, context, include_separators=False)

def get_target_data_enum(self, context, include_separators=True):
    """Gets enum entries for target data to store data from attribute. Contains separators and newlines.

    Args:
        context (Reference): Blender context reference
        include_separators (bool): Whether to include newlines and separators for enum dropdown menu 

    Returns:
        list: List of tuples to be used as enum entries
    """
    items = []
    obj = context.active_object
    active_attrib = obj.data.attributes.active
    inv_data_entry = ("NULL", "[!] No Convertable Data", "")


    for i, entry in enumerate(static_data.object_data_targets):
        if "INSERT_SEPARATOR" in entry and include_separators:
            items.append((None))
        elif "INSERT_NEWLINE" in entry and include_separators:
            items.append(("","","","",i))
        else:
            minver = static_data.object_data_targets[entry].min_blender_ver
            unsupported_from = static_data.object_data_targets[entry].unsupported_from_blender_ver

            if etc.get_blender_support(minver, unsupported_from): 
                icon = get_mesh_data_enum_entry_icon(static_data.object_data_targets[entry])
                if etc.get_enhanced_enum_titles_enabled():
                    name = static_data.object_data_targets[entry].enum_gui_friendly_name
                else:
                    name = static_data.object_data_targets[entry].enum_gui_friendly_name_no_special_characters
                item = (entry,
                        name, 
                        static_data.object_data_targets[entry].enum_gui_description,
                        icon,
                        i
                        )
                items.append(item)

    # this should not happen but since it is already coded here...
    if not len(items):
        return [inv_data_entry]
    
    return items

def get_target_data_enum_with_separators(self, context):
    return get_target_data_enum(self, context, include_separators=True)

def get_target_data_enum_without_separators(self, context):
    return get_target_data_enum(self, context, include_separators=False)

def get_supported_domains_for_selected_mesh_data_target_enum_entry(self, context):
    """Gets all compatible domains for selected data type as enum entries. 

    Example being mean bevel that can be stored either in edges or vertices.

    [!] self object has to have data_target_enum enum property.

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """

    domains_supported = static_data.object_data_targets[self.data_target_enum].domains_supported
    items = []

    if 'POINT' in domains_supported:
        items.append(("POINT", "Vertex", "Store this data in vertices"))
    if 'EDGE' in domains_supported:
        items.append(("EDGE", "Edge", "Store this data in edges"))
    if 'FACE' in domains_supported:
        items.append(("FACE", "Face", "Store this data in faces"))
    if 'CORNER' in domains_supported:
        items.append(("CORNER", "Face Corner", "Store this data in face corners"))
    
    return items

def get_attribute_data_types_enum(self,context):
    """Gets all attribute data types that are supported by current blender version as enum entries

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    l = []  
    for item in static_data.attribute_data_types:
        if etc.get_blender_support(static_data.attribute_data_types[item].min_blender_ver, static_data.attribute_data_types[item].unsupported_from_blender_ver):
            l.append((item, static_data.attribute_data_types[item].friendly_name, ""))
    return l

def get_attribute_data_types():
    """Gets all attribute data types that are supported by current blender version

    Returns:
        list: List of strings
    """
    l = []  
    for item in static_data.attribute_data_types:
        if etc.get_blender_support(static_data.attribute_data_types[item].min_blender_ver, static_data.attribute_data_types[item].unsupported_from_blender_ver):
            l.append(item)
    return l

def get_attribute_domains_enum(self, context):
    """Gets all attribute domains that are supported by current blender version as enum entries

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    l = []
    for item in static_data.attribute_domains:
        if etc.get_blender_support(static_data.attribute_domains[item].min_blender_ver, static_data.attribute_domains[item].unsupported_from_blender_ver):
            l.append((item, static_data.attribute_domains[item].friendly_name, ""))
    return l

def get_attribute_domains():
    """Gets all attribute domains that are supported by current blender version

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of str
    """

    l = []
    for item in static_data.attribute_domains:
        if etc.get_blender_support(static_data.attribute_domains[item].min_blender_ver, static_data.attribute_domains[item].unsupported_from_blender_ver):
            l.append(item)
    return l

def get_attribute_invert_modes(self, context):
    """Returns a list of available modes to invert the active attribute, as enum entries.

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """

    dt = context.active_object.data.attributes.active.data_type

    # Check if this data is supported by the addon
    if not dt in static_data.attribute_data_types.keys():
        return[('NULL', "Data Type Unsupported", "")]
    
    # Get each supported mode to invert this attribute
    l = []
    for item in static_data.attribute_data_types[dt].supported_attribute_invert_modes:
        l.append((item, static_data.attribute_invert_modes[item].friendly_name, static_data.attribute_invert_modes[item].description))

    return l

def get_convert_attribute_modes_enum(self, context):
    """Gets all attribute convert modes

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    return static_data.attribute_convert_modes

def get_vertex_weight_attributes_enum(self, context):
    """Gets all attributes to syue as weight attribute when setting to vertex group index

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    if hasattr(self, 'b_vgindex_weights_only_floats'):
        if not self.b_vgindex_weights_only_floats:
            return get_attributes_of_type_enum(self, context, [], [])
    return get_attributes_of_type_enum(self, context, ['FLOAT'], ['POINT'])

def get_sculpt_mode_attributes_enum(self, context):
    """Gets all attributes to use as sculpt mode mask or face set

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    gui_prop_group = context.window_manager.MAME_GUIPropValues

    
    if gui_prop_group.qops_sculpt_mode_attribute_show_unsupported:
            return get_attributes_of_type_enum(self, context, [], [])
    else:
        if gui_prop_group.enum_sculpt_mode_attribute_mode_toggle == 'MASK':
            return get_attributes_of_type_enum(self, context, ['FLOAT'], ['POINT'])
        else:# data.enum_sculpt_mode_attribute_mode_toggle == 'FACE_SETS':
            attrs = get_attributes_of_type_enum(self, context, ['INT'], ['FACE'])
            # Remove '.sculpt_face_set' aka current face set
            for e in attrs:
                if e[0] == '.sculpt_face_set':
                    attrs.remove(e)
                    break
            return attrs

def get_texture_coordinate_attributes_enum(self, context):
    return get_attributes_of_type_enum(self, context, ['FLOAT2', 'INT32_2D', 'FLOAT_VECTOR'], exclude_names=['position'])

def get_attributes_of_type_enum(self, context, data_types = [], domains = ['POINT'], exclude_names = [], case_sensitive_name_filter = True):
    """Gets all attributes by data type to use in enum dropdown.

    Args:
        context (Reference): Blender context reference
        data_types (list of str): All data type names to filter attributes like ['INT', 'FLOAT'], can be empty/None for all
        domians (list of str): All domains of specified domain, can be empty/None for all
    Returns:
        list: List of tuples to be used in enum
    """
    obj = context.active_object

    enum_entries = []
    inv_data_entry = ("NULL", "[!] No valid attribues", "This list should contain all compatible attributes")

    # Get all if empty or none
    if not data_types or not len(data_types):
        data_types = [dt for dt in static_data.attribute_data_types]

    if not domains or not len(domains):
        domains = [dt for dt in static_data.attribute_domains]

    for attrib in obj.data.attributes:
        if attrib.domain in domains and attrib.data_type in data_types:
            if (attrib.name not in exclude_names and not case_sensitive_name_filter) or (attrib.name.upper() not in [en.upper() for en in exclude_names] and case_sensitive_name_filter):
                enum_entries.append((attrib.name, attrib.name, f"Use {attrib.name} as a source attribute"))
    
    if not len(enum_entries):
        return [inv_data_entry]
    
    return enum_entries
 
def get_attribute_comparison_conditions_enum_for_property(self,context):
    """All available conditions for attributes that store numeric values

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    obj = context.active_object
    a = get_active_attribute(obj)
    
    return get_attribute_comparison_conditions_enum(a.data_type)
    
def get_attribute_comparison_conditions_enum_strings(self, context):
    return get_attribute_comparison_conditions_enum('STRING')

def get_attribute_comparison_conditions_enum(data_type):
    l= []
    for mode in static_data.attribute_data_types[data_type].supported_comparison_modes:
        l.append(static_data.attribute_comparison_modes[mode])
    return l

def get_image_channel_datasource_enum(self, context, index):
    obj = context.active_object
    
    sourcetype = getattr(self, f'source_attribute_{index}_datasource_enum')
    
    l = []

    # enum dirty fix
    if sourcetype == "":
        setattr(self, f'source_attribute_{index}_datasource_enum', 0)
        return []

    l.append(("NULL", "None (Leave as is)", "Leave initial value in this channel intact"))
    
    if sourcetype == 'ATTRIBUTE':
        for a in obj.data.attributes:
            l.append((a.name, a.name, f"Use value from {a.name}"))
    else:
        for img in bpy.data.images:
            l.append((img.name, img.name, f"Use image channel value from {img.name}"))       
    return l

def get_image_channel_datasource_type_enum(self, context):
    l = []
    l.append(("ATTRIBUTE", "Attribute", "Leave initial value in this channel intact"))
    l.append(("IMAGE", "Image", "Leave initial value in this channel intact"))
    return l

def get_image_channel_datasource_vector_subelement_enum(attr_or_tex, texture= False, individual_channels_only = False, alpha_allowed = False):
    
    # 0 = R X
    # 1 = G Y
    # 2 = B Z
    # 3 = A W
    # 4 = XY
    # 5 = RGB XYZ
    # 6 = RGBA XYZW

    l = []

    if texture:
        if attr_or_tex.alpha_mode != 'NONE' and alpha_allowed and not individual_channels_only:
            l.append(("6", 'RGBA', f"Use RGBA subelements"))

        if not individual_channels_only:
            l.append(("5", 'RGB', f"Use RGB subelements"))

        l.append(("0", 'R', f"Use R subelement"))
        l.append(("1", 'G', f"Use G subelement"))
        l.append(("2", 'B', f"Use B subelement"))
        if attr_or_tex.alpha_mode != 'NONE':
            l.append(("3", 'A', f"Use A subelement"))
        return l
    else:
        gui_proptype = static_data.attribute_data_types[attr_or_tex.data_type].gui_prop_subtype
        if gui_proptype not in [static_data.EDataTypeGuiPropType.COLOR, static_data.EDataTypeGuiPropType.VECTOR]:
            return []
        
        vec_el = static_data.attribute_data_types[attr_or_tex.data_type].vector_subelements_names

        # get xyzw
        if len(vec_el) == 4 and not individual_channels_only and alpha_allowed:
            x = str(vec_el[0]+vec_el[1]+vec_el[2]+vec_el[3])
            l.append(("6", x, f"Use {x} subelements"))

        # get xyz
        if len(vec_el) >= 3 and not individual_channels_only:
            x = str(vec_el[0]+vec_el[1]+vec_el[2])
            l.append(("5", x, f"Use {x} subelements"))

        # xy for uvmaps
        if len(vec_el) == 2 and not individual_channels_only:
            x = str(vec_el[0]+vec_el[1])
            l.append(("4", x, f"Use {x} subelements"))

        # get x,y,z,w
        for i, el in enumerate(vec_el):
            l.append((str(i), el, f"Use {el} subelement"))

        return l

def get_image_channel_datasource_vector_element_enum(self, context, index, alpha_allowed):
    """The function that detects which of the the XYZW XYZ X Y Z  channel of the attribute 
    to bake to texture should be shown in GUI.

    Can't put it in the operator

    Returns:
        enum list
    """
    src_attribute_enum = getattr(self, f'source_attribute_{index}_enum')
    
    # enum dirty fix
    if src_attribute_enum == "":
        setattr(self, f'source_attribute_{index}_enum', 0)
        return []
    elif src_attribute_enum == 'NULL':
        return []
    

    
    is_texture = getattr(self, f'source_attribute_{index}_datasource_enum') == 'IMAGE'
    only_subelements = self.image_channels_type_enum == 'ALL' 
    if is_texture:
        attr_or_img = bpy.data.images[src_attribute_enum]
    else:
        attr_or_img = context.active_object.data.attributes[src_attribute_enum]
        
    return get_image_channel_datasource_vector_subelement_enum(attr_or_img, is_texture, only_subelements, alpha_allowed)


# Multi-use operator poll functions
# --------------------------------

def conditional_selection_poll(self, context):
    """Used in multiple ops that are used for selecting attributes by condition on their values

    Args:
        context (Reference): Blender context reference

    Returns:
        boolean
    """
    if not context.active_object:
        self.poll_message_set("No active object")
        return False
    
    elif not context.active_object.mode == 'EDIT':
        self.poll_message_set("Object not in edit mode")
        return False
    
    elif not context.active_object.type == 'MESH':
        self.poll_message_set("Object is not a mesh")
        return False

    elif context.active_object.data.attributes.active is None:
        self.poll_message_set("No active attribute")
        return False

    elif not static_data.EAttributeType.NOTPROCEDURAL not in get_attribute_types(context.active_object.data.attributes.active):
        self.poll_message_set("Attribute cannot be selected (Non-procedural)")
        return False
    
    elif not get_attribute_compatibility_check(context.active_object.data.attributes.active):
        self.poll_message_set("Attribute is unsupported in this addon version")
        return False
    
    return True


# Color
# --------------------------------

def color_vector_to_hsv(color):
    """Converts a 4 dimensional tuple contatining color values in RGB to HSV values. 

    Args:
        color (tuple): 4 dimensional color tuple in RGB

    Returns:
        tuple: 4 dimensional color tuple in HSV
    """
    return tuple(colorsys.rgb_to_hsv(color[0], color[1], color[2])) + (color[3],)

def color_vector_to_rgb(color):
    """Converts a 4 dimensional tuple contatining color values in HSV to RGB values. 

    Args:
        color (tuple): 4 dimensional color tuple in HSV

    Returns:
        tuple: 4 dimensional color tuple in RGB
    """
    return tuple(colorsys.hsv_to_rgb(color[0], color[1], color[2])) + (color[3],)

def linear_to_srgb(color_value: float, return_float=True):
    # https://b3d.interplanety.org/en/color-conversion-from-linear-to-srgb-color-space-and-back-in-blender/
    if color_value <= 0.0031308:
        v = int(12.92 * color_value * 255.99)
        return max(min(1.0, v/255),0.0) if return_float else v 
    else:
        v = int((1.055 * color_value ** (1 / 2.4) - 0.055) * 255.99)
        return max(min(1.0, v/255),0.0) if return_float else v 
    

# Other
# --------------------------------

def is_verbose_mode_enabled():
    """Returns a boolean if the verbose logging to console is enabled

    Returns:
        bool
    """
    return etc.get_preferences_attrib('verbose_mode')

def get_attribute_compatibility_check(attribute):
    """Returns true if the attribute is compatible with this addon.

    Args:
        attribute (ref): Reference to attribute

    Returns:
        bool: True if the support for this attribute type was implemented
    """
    if attribute.data_type not in static_data.attribute_data_types:
        return False
    elif attribute.domain not in static_data.attribute_domains:
        return False
    return True


# Node Editors 
# ----------------------------------------------

def get_node_editor_type(area = None, use_id = False, return_enum=False):
    """Returns an enum of ENodeEditor for given area or a string

    Args:
        area (ref, optional): Reference to area from window_manager.windows.screen.area
        use_id (bool, optional): Whether to use (window_id, area_id) tuple instead of reference. Defaults to False.
        return_enum (bool, optional): Whether to return static_data.ENodeEditor instead of tree_type string. Defaults to False.

    Returns:
        ENodeEditor or str: type of the node tree in node editor
    """
    if use_id:
        area = bpy.context.window_manager.windows[area[0]].screen.areas[area[1]]

    if area.type != 'NODE_EDITOR':
        return None
    elif return_enum:
        if area.spaces[0].tree_type in static_data.node_editors:
            return static_data.node_editors[area.spaces[0].tree_type].enum
        else:
            return None
    else:
        return area.spaces[0].tree_type
        
def get_node_editor_areas(ids=False):
    """Returns all areas that are node editors

    Args:
        ids (bool, optional): Return a tuple with index for windoww, and index for area in (x, y) format. Defaults to False.

    Returns:
        list of ref or list of tuple: References to areas, or 2 dimensional tuples to window id and area ids
    """
    areas = []
    for w, window in enumerate(bpy.context.window_manager.windows):
        for a, area in enumerate(window.screen.areas):
            if area.type == 'NODE_EDITOR':
                areas.append((w, a)) if ids else areas.append(area)

    return areas

def get_area_node_tree(area, useid = False):
    if useid:
        area = bpy.context.window_manager.windows[area[0]].screen.areas[area[1]]

    return area.spaces[0].node_tree

def get_supported_areas_for_attribute(attribute, ids = False):
    """Gets supported node editors for specified attribute to create attribute node in.

    Args:
        attribute (ref): Reference to the attribute
        ids (bool, optional): Return a tuple with index for windoww, and index for area in (x, y) format. Defaults to False.

    Returns:
        ref or tuple: Reference to area, or 2 dimensional tuple to window id and area id
    """

    areas = get_node_editor_areas(True) # returns tuple window id area id
    
    attribute_suppported_area_types = static_data.attribute_data_types[attribute.data_type].compatible_node_editors
    supported_areas = []
    for area in areas:
        arearef = bpy.context.window_manager.windows[area[0]].screen.areas[area[1]]

        node_editor_type = get_node_editor_type(arearef, return_enum=True)
        if node_editor_type in attribute_suppported_area_types:
            if node_editor_type == static_data.ENodeEditor.GEOMETRY_NODES and not etc.get_blender_support(minver=(3,2,0)):
                continue
            else:
                supported_areas.append(area if ids else arearef)

    
    return supported_areas

def get_node_tree_parent(node_tree, tree_type = None):
    """
    Gets the parent (likely material reference) of the node tree

    Args:
        node_tree (Reference): Reference to node tree
        tree_type (static_data.ENodeEdtior) (Optional): To limit the search to specific tree type it can be specified

    Returns:
        Reference to the parent, likely the material reference
    """
    if tree_type in [None, static_data.ENodeEditor.SHADER]:
        for mat in bpy.data.materials:
            if mat.node_tree == node_tree:
                return mat
    elif tree_type in [None, static_data.ENodeEditor.GEOMETRY_NODES]:
        for gn in bpy.data.node_groups:
            if gn.node_tree == node_tree:
                return gn
    else: 
        return None


# CSV Export related
# ----------------------------------------------
 
def write_csv_attributes_file(filepath:str, obj, attributes: list, add_domain_and_data_type_to_title_row = True):
    """Writes specified attrtibutes to .csv file specified in filepath

    Args:
        filepath (str): path to the file
        obj (_type_): object to take attributes from
        attributes (list): list of attribute references to take data from

    Exceptions:
        PermissionError
    """

    # add csv extension
    if not filepath.lower().endswith('.csv'):
        filepath += ".csv"

    if is_verbose_mode_enabled():
            print(f"Exporting to CSV file located at \"{filepath}\"")

    with open(filepath, 'w', newline='') as csvfile:

        rownames = []
        datalengths = []
        values = []

        for attribute in attributes:
            if add_domain_and_data_type_to_title_row:
                rownames.append(str(attribute.name + "(" + attribute.data_type + ")(" + attribute.domain+")"))
            else:
                rownames.append(attribute.name)
            datalengths.append(len(attribute.data))
            values.append(get_attribute_values(attribute, obj))

        max_data_len = max(datalengths)

        writer = csv.DictWriter(csvfile, fieldnames=rownames)
        writer.writeheader()

        for i in range(0, max_data_len):

            row = {}
            for j, attribute in enumerate(attributes):
                rownames[j].replace(',', "")
                if i < datalengths[j]:
                    row[rownames[j]] = values[j][i]
                else:
                    row[rownames[j]] = ""

            writer.writerow(row)

    if is_verbose_mode_enabled():
            print(f"Wrote {max_data_len+1} lines.")

def csv_to_attributes(filepath:str, obj, excluded_attribute_names: list, remove_domain_from_name: bool = True, remove_datatype_from_name: bool = True,
                      force_domain: str = '', force_data_type: str = ''):
    """Converts CSV file to active mesh attributes

    Args:
        filepath (str): The path to the CSV file
        obj (ref): Reference to the object to store the attributes in
        excluded_attribute_names (list): List of attriubte names that should be ignored while importing+
        remove_domain_from_name (bool, optional): Whether to remove the strings like (POINT) from attribute name if title row contains it. Defaults to True.
        remove_datatype_from_name (bool, optional): Whether to remove the strings like (FLOAT) from attribute name if title row constains it. Defaults to True.
        force_domain (str, optional): Name of the domain to override all imported attributes to be stored in. Use same naming convetion as blender, eg. POINT. Defaults to ''.
        force_data_type (str, optional): Name of the data type to override all imported attributes to be. Use same naming convetion as blender, eg. FLOAT_VECTOR. Defaults to ''.

    Returns:
        Status (bool): True on success
        Errors list (list): List of str elements that contain error descriptions
        New attribute count (int): the count of attributes imported or created.
    """

    if is_verbose_mode_enabled():
            print(f"Creating and writing attributes from CSV file located at \"{filepath}\"")
    
    errors = []

    with open(filepath, 'r', newline='') as csvfile:
        reader = csv.reader(csvfile, delimiter=',')

        attribute_sets = []
        valid_columns = []
        data_columns = []

        line = 0
        for row in reader:
            line += 1
            if line == 1:
                # read attributes
                for col_id, column in enumerate(row):
                    if not column.endswith(')') and (force_domain != '' or force_data_type != ''):
                        errors.append(f"Column {col_id} title invalid: {column}")
                        continue
                    
                    # find domain
                    attrib_domain = None
                    domains = get_attribute_domains()

                    if force_domain == '' or remove_domain_from_name:
                        # check for longest first
                        domains.sort(key=len, reverse=True)

                        for dom in domains:
                            foundat = column.rfind("(" + dom.upper() + ")")
                            if foundat != -1:
                                attrib_domain = dom
                                if remove_domain_from_name:
                                    column = column[:foundat] + column[foundat+len(dom)+2:]
                                break
                    
                    if force_domain != '':
                        attrib_domain = force_domain
                    

                    if attrib_domain is None or attrib_domain not in domains:
                        errors.append(f"Can't determine domain or domain unsupported in this blender version for column {col_id}: {column}")
                        continue

                    # find data type
                    attrib_dt = None
                    data_types = static_data.attribute_data_types #get_attribute_data_types()

                    if force_data_type == '' or remove_datatype_from_name:

                        for dt in data_types:
                            foundat = column.rfind("(" + dt.upper() + ")")
                            if foundat != -1:
                                attrib_dt = dt
                                if remove_datatype_from_name:
                                    column = column[:foundat] + column[foundat+len(dt)+2:]
                                break
                    
                    if force_data_type != '':
                        attrib_dt = force_data_type

                    if attrib_dt is None or attrib_dt not in data_types:
                        errors.append(f"Can't determine data type in column {col_id}: {column}")
                        continue

                    if attrib_dt not in get_attribute_data_types():
                        errors.append(f"Data type \"{attrib_dt}\" unsupported in this blender version in column {col_id}: {column}")
                        continue

                    
                    # remove
                    column = column.replace('(', "")
                    column = column.replace(')', "")

                    if column in obj.data.attributes:
                        attribute = obj.data.attributes[column]
                        if attribute.data_type != attrib_dt:
                            errors.append(f"This attribute exists, but the data type is different: column {col_id}: {column}")
                            continue
                        elif attribute.domain != attrib_domain:
                            errors.append(f"This attribute exists, but the domain is different: column {col_id}: {column}")
                            continue
                    else:
                        if column == "":
                            errors.append(f"Cannot create an attribute with empty name, column {col_id}")
                            continue
                        
                        attribute = obj.data.attributes.new(name=column, type=attrib_dt, domain=attrib_domain)

                    if attribute in excluded_attribute_names:
                        if is_verbose_mode_enabled():
                            print(f"Attribute on exclude list: {col_id} {column}")
                        continue

                    # Because this script can create many attributes quickly, blender might not update the data about
                    # domains and data types fast enough to be accessible via .data_type and .domain
                    # so this has to be passed through manually

                    aset = {
                        "attribute": attribute,
                        "name": column, 
                        "data_type": attrib_dt,
                        "domain": attrib_domain
                    }
                    attribute_sets.append(aset)
                    valid_columns.append(col_id)
                    data_columns.append([])
                    if is_verbose_mode_enabled():
                        print(f'Identified column {col_id} as {column}, domain {attrib_domain}, data type {attrib_dt}')
                
                obj.data.update()
            
            else:
                if not len(valid_columns):
                    errors.append('No valid fields detected')
                    return False, errors, 0
                
                for i, col_id in enumerate(valid_columns):
                    attribute_set = attribute_sets[i]
                    if is_verbose_mode_enabled():
                        print(f"[COL {col_id}][ROW: {line-1}] Reading data for attribute {attribute_set['name']}, domain {attribute_set['domain']}, data type {attribute_set['data_type']}")
                    
                    cast_type = static_data.attribute_data_types[attribute_set['data_type']].cast_type
                    
                    data = row[col_id]
                    if data == "" and cast_type is not string:
                        continue

                    try:
                        if cast_type is not tuple:
                            data_columns[i].append(cast_type(data))
                        else:
                            if type(literal_eval(data)) != cast_type:
                                raise ValueError
                            data_columns[i].append(literal_eval(data))
                    except ValueError:
                        errors.append(f"Cannot convert {data} from column {col_id}, row {line-1} to {cast_type}, using default value for this data type.")
                        data_columns[i].append(get_attribute_default_value(attribute))



        for i, attribute_set in enumerate(attribute_sets):
            attribute = attribute_set['attribute']
            input_data_len = len(data_columns[i])
            storage_len = len(attribute.data)
            if input_data_len < storage_len:
                data_columns[i] += [get_attribute_default_value(attribute)] * (storage_len-input_data_len)
            elif input_data_len > storage_len:
                data_columns[i] = data_columns[i][:storage_len]

            set_attribute_values(attribute, data_columns[i], bugbypass_data_type=attribute_set['data_type'], bugbypass_domain=attribute_set['domain'])




    return True, errors, len(attribute_sets)


# UILIsts
# ----------------------------------------------

def refresh_attribute_UIList_elements():
        obj = bpy.context.active_object
        gui_prop_group = bpy.context.window_manager.MAME_GUIPropValues
        list_elements = gui_prop_group.to_mesh_data_attributes_list

        list_elements.clear()
        
        for attrib in obj.data.attributes:
            el = list_elements.add()
            el.attribute_name = attrib.name
            el.domain = attrib.domain
            el.domain_friendly_name = get_friendly_domain_name(attrib.domain, short=True)
            el.data_type = attrib.data_type
            el.data_type_friendly_name = get_friendly_data_type_name(attrib.data_type)

def set_attribute_uilist_compatible_attribute_type(domain, data_type):
    """Updates elements in UIList to red-highlight attributes that do not have specified domain or data type 

    Args:
        domain (str): domain
        data_type (str): data type
    """
    obj = bpy.context.active_object
    gui_prop_group = bpy.context.window_manager.MAME_GUIPropValues

    for el in gui_prop_group.to_mesh_data_attributes_list:
                
                el.b_domain_compatible = el.domain == domain
                el.b_data_type_compatible = el.data_type == data_type

def configutre_attribute_uilist(enable_same_as_target_filter_btn: bool,
                                enable_incompatible_type_highlight: bool):
    
    gui_prop_group = bpy.context.window_manager.MAME_GUIPropValues
    gui_prop_group.b_attributes_uilist_show_same_as_target_filter = enable_same_as_target_filter_btn
    gui_prop_group.b_attributes_uilist_highlight_different_attrib_types = enable_incompatible_type_highlight


# Rendering & Images
# ----------------------------------------------

def get_cycles_available():
    """Checks if the Cycles Render Engine is enabled and available

    Returns:
        bool: status
    """
    return 'cycles' in bpy.context.preferences.addons

def get_alpha_channel_enabled_texture_bake_op(self):
    # Used in AttributesToImage operqtor, can't put it in the operator.
    # Checks if alpha channel is enabled to bake it
    img_ref = bpy.context.window_manager.mame_image_ref
    return((self.image_source_enum == 'NEW' and self.b_new_image_alpha) or (self.image_source_enum == 'EXISTING' and img_ref is not None and img_ref.alpha_mode != 'NONE'))
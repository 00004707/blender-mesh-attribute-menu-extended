"""
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.
If not, see <https://www.gnu.org/licenses/>.
"""

"""
func

Function definitions 
"""

import bpy 
import bmesh
import math
from . import etc
from . import data
import numpy as np

# Attribute related
# ------------------------------------------

# get

def get_attribute_types(attribute):
    """Checks for attribute type, eg hidden, autogenerated, and other.

    Args:
        attrib_name (string): Name of the attribute

    Returns:
        list: List of data.EAttributeType
    """

    at = []

    # check for hidden
    if attribute.name.startswith('.'):
        at.append(data.EAttributeType.HIDDEN)

    # check for presets
    if attribute.name in data.defined_attributes.keys():
            at += data.defined_attributes[attribute.name].types
    else:
        at.append(data.EAttributeType.NORMAL)

    return at

def get_is_attribute_valid_for_manual_val_assignment(attribute):
    """Checks if the attribute is a valid attribute to assign values to it in edit mode

    Args:
        attrib_name (string): Name of the attribute

    Returns:
        list: List of data.EAttributeType
    """
    return not bool(len([atype for atype in get_attribute_types(attribute) if atype in [data.EAttributeType.READONLY, data.EAttributeType.NOTPROCEDURAL]]))

def get_attrib_value_propname(attribute):
    """Gets the property name of attribute value. Some values are stored in .vector others in .value etc.

    Args:
        attribute (Reference): Attribute reference variable

    Returns:
        string: Attribute property name
    """
    if attribute.data_type in ["FLOAT_VECTOR", "FLOAT2"]:
        return "vector"
    elif attribute.data_type in ["FLOAT_COLOR", "BYTE_COLOR"]:
        return "color"
    else:
        return "value"

def get_attrib_values(attribute, obj):
    """Reads all attribute values using foreach_get

    Args:
        attribute (Reference): Attribute reference variable
        obj (Reference): Reference to an 3D object that stores that attribute

    Raises:
        etc.MeshDataReadException: If source data type is not implemented
        
    Returns:
        list: Attribute values, data type unchanged
    """

    value_attrib_propname = get_attrib_value_propname(attribute)
    dt = attribute.data_type

    if is_verbose_mode_enabled():
        print(f"Getting {attribute.name} values: data type = {dt} ({attribute.data_type}), prop = {value_attrib_propname}, len = {len(attribute.data)}" )

    
    if dt == "FLOAT":
        a_vals = [0.0] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "INT":
        a_vals = [0] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "FLOAT_VECTOR":
        a_vals = [0.0] * (len(attribute.data) * 3) # why not Vector()? 
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2]) for i in range(0, len(a_vals), 3)]
    elif dt == "FLOAT_COLOR":
        a_vals = [0.0] * (len(attribute.data) * 4)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2], a_vals[i+3]) for i in range(0, len(a_vals), 4)]
    elif dt == "BYTE_COLOR":
        a_vals = [0.0] * (len(attribute.data) * 4)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2], a_vals[i+3]) for i in range(0, len(a_vals), 4)]
    elif dt == "BOOLEAN":
        a_vals = [False] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "FLOAT2":
        a_vals = [0.0] * (len(attribute.data) * 2)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1]) for i in range(0, len(a_vals), 2)]
    elif dt == "INT32_2D":
        a_vals = [0] * (len(attribute.data) * 2)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1]) for i in range(0, len(a_vals), 2)]
    elif dt == "QUATERNION":
        a_vals = [0.0] * (len(attribute.data) * 4)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2], a_vals[i+3]) for i in range(0, len(a_vals), 4)]
    elif dt == "INT8":
        a_vals = [0] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "STRING":
        # Foreach set get does not support strings.
        a_vals = []
        for entry in attribute.data:
            a_vals.append(entry.value)
        return a_vals
    else:
        raise etc.MeshDataReadException('get_attrib_values', f"Data type {dt} is unsupported.")

def get_attrib_default_value(attribute):
    """Returns the zero value for attribute data type. Does not return a list with the length of the attribute data!

    Args:
        attribute (Reference): Reference to the attribute
    
    Raises:
        etc.MeshDataReadException: If source data type is not implemented

    Returns:
        Variable type: The default value for single attribute value
    """
    dt = attribute.data_type
    if dt == "FLOAT":
        return 0.0 
    elif dt == "INT":
        return 0 
    elif dt == "FLOAT_VECTOR":
        return (0.0, 0.0, 0.0) 
    elif dt == "FLOAT_COLOR":
        return (0.0, 0.0, 0.0, 0.0)
    elif dt == "BYTE_COLOR":
        return (0.0, 0.0, 0.0, 0.0)
    elif dt == "STRING":
        return "" 
    elif dt == "BOOLEAN":
        return False
    elif dt == "FLOAT2":
        return (0.0, 0.0)
    elif dt == "INT32_2D":
        return (0, 0)
    elif dt == "QUATERNION":
        return (1.0, 0.0, 0.0, 0.0)
    elif dt == "INT8":
        return 0 
    else:
        raise etc.MeshDataReadException('get_attrib_default_value', f"Data type {dt} is unsupported.")

def get_safe_attrib_name(obj, attribute_name, suffix = "Attribute"):
    """Gets safe attribute name to avoid crashes in some instances.
    ie. Naming attribute the same name as Vertex Group can crash blender.

    Args:
        obj (Reference): 3D Object reference
        attribute_name (str): Name of the attribute to check
        suffix (str, optional): The suffix to add to the name if the name is not safe. Defaults to "Attribute".

    Returns:
        str: Safe attribute name
    """
    while(attribute_name in obj.vertex_groups.keys()):
            attribute_name += " " + suffix

    return attribute_name

def get_random_attribute_of_data_type(context, data_type:str):
    return

# set

def set_attribute_values(attribute, value, on_indexes = [], flat_list = False):
    """Sets attribute values. Accepts both lists and single values.
    WARNING: OBJECT MODE REQUIRED

    Args:
        attribute (Reference): Reference to the attribute
        value (list or value): The value or values to set
        on_indexes (list, optional): Indexes to set the value on. Defaults to []. Duplicates WILL NOT be checked
        flat_list (bool, optional): Only for setting ALL values. Used in case when the target accepts vector values (tuples), but the input list is single dimension eg. [3,3,3] instead of [(3,3,3)]. Defaults to False.

    Raises:
        etc.MeshDataWriteException: On failure

    Returns:
        Nothing 
    """

    """
    For a mesh of 30,722 vertices
    Setting all values using foreach set only: ~~ 0.013s to finish (ALL values to single one)
    Setting all values using foreach get, foreach set ~~ 0.21s to finish
    Setting all values using for loop over .value ~~ 0.49s to finish
    
    I'm not smart enough to calculate computation complexity, but eyeballing it on multiple meshes resulted in strategy that
    <25% mesh for loop
    >25% mesh, foreach get foreach set
    all just foreach set

    setattr is noticeably slower

    guess it's a call to finally learn how to program and count for real
    """
    
    # Foreach_set
    # Note: Strings do not support FOREACH_SET
    if is_verbose_mode_enabled():
        print(f"""
SETTING ATTRIBUTE VALUES
ATTRIBUTE: {attribute.name}
VALUE: {value}
ON_INDEXES: {on_indexes}
FLAT_LIST: {flat_list}              
""")

    if (len(on_indexes) == 0 or len(on_indexes) == len(attribute.data)) and attribute.data_type != 'STRING' :
        etc.pseudo_profiler("FOR_EACH_START")
        prop_name = get_attrib_value_propname(attribute)
        if is_verbose_mode_enabled():
            print(f"Setting {attribute.name} attribute values for each domain. Expected data length {len(attribute.data)}, input data length {len(value)}")

        # create storage
        if flat_list:
            storage = value
        elif type(value) is list:
            if len(value) != len(attribute.data):
                print(f"INPUT DATA INVALID LEN {len(value)} EXPECTED {len(attribute.data)} VALUES:\n{value}")
                raise etc.MeshDataWriteException("set_attribute_values", "Invalid input value data length.")
            
            # convert to single dimension list if of vector type
            if attribute.data_type in ['FLOAT_VECTOR', 'FLOAT2', 'FLOAT_COLOR', 'BYTE_COLOR', 'INT32_2D', 'QUATERNION']:
                storage = value.flatten()
                etc.pseudo_profiler("1D LIST CREATED")
            else:
                storage = value
            
        else:
            storage = np.repeat(value, len(attribute.data))
        etc.pseudo_profiler("STORAGE_CREATED")
        
        attribute.data.foreach_set(prop_name, storage)
        etc.pseudo_profiler("FOREACH SET DONE")

    # on selected indexes mode
    else:
        if is_verbose_mode_enabled():
            print(f"Setting {attribute.name} attribute values for {len(on_indexes)} domains. ")

        prop = get_attrib_value_propname(attribute)
        dt = attribute.data_type
        domain = attribute.domain
        
        # FOREACH_GET_FOREACH_SET for > 25%
        if len(on_indexes) > len(attribute.data)/4 and attribute.data_type != 'STRING':
            etc.pseudo_profiler("FOREACH_GET_FOREACH_SET")
            
            prop_name = get_attrib_value_propname(attribute)
            storage = np.repeat(value, len(attribute.data))
            attribute.data.foreach_get(prop_name, storage)
            if type(value) == tuple:
                for i in on_indexes:
                    for l in range(0, len(value)):
                        storage[i*len(value)+l] = value[l]
            else:
                storage[on_indexes] = value
            attribute.data.foreach_set(prop_name, storage)

        # For loop for < 25% mesh selected
        else:
            etc.pseudo_profiler("SET_VAL_ON_SELECTION_START")
            if prop == "vector":
                for i in on_indexes:
                    attribute.data[i].vector = value
            elif prop == "color":
                for i in on_indexes:
                    attribute.data[i].color = value
            else: # "value"
                for i in on_indexes:
                    attribute.data[i].value = value

            etc.pseudo_profiler("SET_VAL_ON_SELECTION_END")
                
            # This would be very nice, but it's slow
            # for i in on_indexes:
            #     if type(value) is list:
            #         setattr(attribute.data[i], prop, value[i%len(value)]) 
            #     else:
            #         setattr(attribute.data[i], prop, value) 
                    
def set_attribute_value_on_selection(self, context, obj, attribute, value, face_corner_spill = False):
    """Assigns a single value to all selected domain in edit mode.

    Args:
        context (Reference): Blender context referene
        obj (Reference): 3D Object Reference
        attribute (Reference): Attribute reference
        value (Variable type): The value to set
        face_corner_spill (bool, optional): Enable spilling the value to nearby face corners. Defaults to False.

    Returns:
        bool: Success status
    """

    # Store active attribute name (and test it) !important
    active_attrib_name = attribute.name 
    active_attrib = obj.data.attributes[active_attrib_name]
    
    if is_verbose_mode_enabled():
        print( f"Working on {active_attrib_name} attribute" )

    # Get selection in edit mode, on attribute domain
    etc.pseudo_profiler("EXEC_START_SET_VAL_ON_SEL")
    selected_el = get_mesh_selected_domain_indexes(obj, active_attrib.domain, face_corner_spill)
    etc.pseudo_profiler("GET_SEL_BY_DOMAIN_DONE")

    if not len(selected_el):
        self.report({'ERROR'}, "Invalid selection or no selection")
        return False
    
    active_attrib = obj.data.attributes[active_attrib_name] # !important get_mesh_selected_by_domain changes the reference

    if is_verbose_mode_enabled():
        print(f"Attribute data length: {len(active_attrib.data)}")
        print(f"Selected domains: [{len(selected_el)} total] - {selected_el}")
        print(f"Setting value: {value}")
        a_vals = get_attrib_values(attribute, obj)
        print(f"Pre-set values: {str(a_vals)}")

    # Write the new values
    #selected_el = [i for i, el in enumerate(selected_el) if el]
    #selected_el = [i.index for i in selected_el]
    etc.pseudo_profiler("GET_SEL_EL_INDEX")
    set_attribute_values(active_attrib, value, selected_el)
    etc.pseudo_profiler("SET_VALUES_END")
    if is_verbose_mode_enabled():
        a_vals = get_attrib_values(attribute, obj)
        print(f"Post-set values: {str(a_vals)}")

    return True

def set_active_attribute(obj, attribute_name):
    """Sets active attribute and avoids the bug that might set the invalid attribute as active

    Args:
        obj (Reference): Object Reference
        attribute_name (str): Attribute name
    """

    atrr_index = obj.data.attributes.keys().index(attribute_name)
    obj.data.attributes.active_index = atrr_index

def convert_attribute(self, obj, attrib_name, mode, domain, data_type):
    """Converts attribute to different type

    Args:
        obj (Reference): 3D Object Reference
        attrib_name (str): Name of the attribute
        mode (enum str): See data.convert_attribute_modes
        domain (enum str): See data.attribute_domains
        data_type (enum str): See data.attribute_data_types

    Raises:
        etc.MeshDataWriteException: On failure
    """

    if is_verbose_mode_enabled():
        print(f"Converting attribute {attrib_name}")
    
    # Auto convert to different data type, if enabled in gui
    attrib = obj.data.attributes[attrib_name]
    
    if attrib is not None:
        set_active_attribute(obj, attrib_name)

        if is_verbose_mode_enabled():
            print(f"Converting {obj.data.attributes.active.name} with settings {mode}, {domain}, {data_type}")

        bpy.ops.geometry.attribute_convert(mode=mode, domain=domain, data_type=data_type)
    else:
        raise etc.MeshDataWriteException('convert_attribute', f"{attrib_name} attribute is None?")

# ------------------------------------------
# Mesh related

# get

def get_mesh_selected_domain_indexes(obj, domain, spill=False):
    """Gets the indexes of selected domain entries in edit mode. (Vertices, edges, faces or Face Corners)

    Args:
        obj (Reference): 3D Object Reference
        domain (str): Mesh Domain
        spill (bool, optional): Enables selection spilling to nearby face corners from selected verts/faces/edges. Defaults to False.

    Raises:
        etc.MeshDataReadException: If domain is unsupported

    Returns:
        list: List of indexes
    """

    if domain == 'POINT': 
        #return [v for v in obj.data.vertices if v.select]
        storage = np.zeros(len(obj.data.vertices), dtype=np.bool)
        obj.data.vertices.foreach_get('select', storage)
        return np.arange(0, len(obj.data.vertices))[storage]
    
    elif domain == 'EDGE': 
        #return [e for e in obj.data.edges if e.select]
        storage = np.zeros(len(obj.data.edges), dtype=np.bool)
        obj.data.edges.foreach_get('select', storage)
        return np.arange(0, len(obj.data.edges))[storage]
    
    elif domain == 'FACE': 
        #return [f for f in obj.data.polygons if f.select]
        storage = np.zeros(len(obj.data.polygons), dtype=np.bool)
        obj.data.polygons.foreach_get('select', storage)
        return np.arange(0, len(obj.data.polygons))[storage]

    elif domain == 'CORNER': 
        # boneless chicken 
        if spill: 
            # Get selected verts ids
            storage = np.zeros(len(obj.data.vertices), dtype=np.bool)
            obj.data.vertices.foreach_get('select', storage)
            sel_verts = np.arange(0, len(obj.data.vertices))[storage]
            
            # Get loop assigned verts
            storage = np.zeros(len(obj.data.loops), dtype=np.int)
            obj.data.loops.foreach_get('vertex_index', storage)

            # Get the loops with the selected verts
            return np.arange(0, len(obj.data.loops))[np.isin(storage, sel_verts)]

        else:
            mesh_selected_modes = bpy.context.scene.tool_settings.mesh_select_mode
            result = [] # ???
            
            # Case: User wants to assign faces
            if mesh_selected_modes[2]: # faces

                # Get selected faces
                face_select = np.zeros(len(obj.data.polygons), dtype=np.bool)
                obj.data.polygons.foreach_get('select', face_select)
                
                # Get face loop indexes
                #face_loop_start_ids = np.zeros(len(obj.data.polygons), dtype=np.int)
                #obj.data.polygons.foreach_get('loop_start', face_loop_indices) # why not?

                face_loop_indices = []
                for i in np.arange(0, len(obj.data.polygons))[face_select]:
                    face_loop_indices += obj.data.polygons[i].loop_indices
                return np.unique(face_loop_indices)#[face_select])
            
            # Case User wants to select individual face corners by edge selection (detect same for vert selection)
            else:
                
                # get selected edges
                b_sel_edges = np.zeros(len(obj.data.edges), dtype=np.bool)
                obj.data.edges.foreach_get('select', b_sel_edges)
                sel_edges = np.arange(0, len(obj.data.edges))[b_sel_edges]
                
                # go away if none selected
                if not len(sel_edges):
                    return []
                
                # get edge indexes for all loops
                loops_edge_index = np.zeros(len(obj.data.loops), dtype=np.int)
                obj.data.loops.foreach_get('edge_index', loops_edge_index)

                # get loops that are connected to selected edges
                loop_ids_of_selected_edges = np.arange(0, len(obj.data.loops))[np.isin(loops_edge_index, sel_edges)]
                
                if is_verbose_mode_enabled():
                    print(f"The selection might be one of {loop_ids_of_selected_edges} fcs")
                
                for fc in [obj.data.loops[li] for li in loop_ids_of_selected_edges]:
                    
                    # Get face that has this loop
                    for f in obj.data.polygons:
                        if fc.index in f.loop_indices:
                            face = f
                            break

                    if is_verbose_mode_enabled():
                        print(f"Face {face.index} has fc {fc.index}")
                        print(f"Face {face.index} has vts {[v for v in face.vertices]}")
                        print(f"Looking for vert {fc.vertex_index}")
                        print(f"Looking in face {face.index}: {list(obj.data.polygons[face.index].loop_indices)}")

                    valid_edges = []
                    for i in obj.data.polygons[face.index].loop_indices:
                        if b_sel_edges[obj.data.loops[i].edge_index]:
                            edge = obj.data.edges[obj.data.loops[i].edge_index]
                            #print(f"{face.index}: has edge with verts {edge.vertices}")
                            edge_verts = [v for v in edge.vertices]

                            if fc.vertex_index in edge_verts:
                                valid_edges.append(edge.index)
                                #print(f"{edge.index} contains the vert of fc")
                    
                    # check if at least two of those edges are selected

                    if len(valid_edges) > 1:
                        result.append(fc.index)
                
                return result
    
    else:
        raise etc.MeshDataReadException('get_mesh_selected_domain_indexes', f'The {domain} domain is not supported')

# TODO this one below

def get_filtered_indexes_by_condition(source_data: list, condition:str, compare_value, case_sensitive_string = False):
    """Gets indexes of the list that store values that meet selected condition

    Currently only one dimensional lists are supported.

    Args:
        source_data (list): The list with data
        condition (str): The condition to check
        compare_value (variable): The value to check the condition with
        case_sensitive_string (bool, optional): Whether the strings should be compared with case sensitivity or not. Defaults to False.

    Returns:
        list: _Indexes of the list that meet the criteria
    """
        # todo flatten the list or handle vectors somehow
        # there has to be an easier way, what the hell is this

    indexes = []
    if is_verbose_mode_enabled():
        print(f"Get filtered indexes with settings:\n{condition} to {compare_value}, case sensitive {case_sensitive_string} \non dataset {source_data}")

    #booleans
    if type(source_data[0]) is bool:
        for i, data in enumerate(source_data):
            if condition == "EQ" and data == compare_value:
                indexes.append(i)

            elif condition == "NEQ" and data != compare_value:
                indexes.append(i)

    # numeric values & floats invididual vals
    elif type(source_data[0]) in [int, float]:
        for i, data in enumerate(source_data):
            if condition == "EQ" and data == compare_value: #equal
                indexes.append(i)

            elif condition == "NEQ" and data != compare_value: # not equal
                indexes.append(i)

            elif condition == "EQORGR" and data >= compare_value: # >=
                indexes.append(i)

            elif condition == "EQORLS" and data <= compare_value: # <=
                indexes.append(i)

            elif condition == "GR" and data > compare_value: # >
                indexes.append(i)

            elif condition == "LS" and data < compare_value: # <
                indexes.append(i)
    
    # strings
    elif type(source_data[0]) == str:
        for i, data in enumerate(source_data):
                
            # case sensitive toggle
            if not case_sensitive_string:
                value = data.upper()
                cmp = compare_value.upper()
            else:
                value = data
            
            if condition == "EQ" and value == cmp: #equal
                indexes.append(i)

            elif condition == "NEQ" and value != cmp: #not equal
                indexes.append(i)
            
            elif condition == "CONTAINS" and cmp in value: # contains
                indexes.append(i)
            
            elif condition == "STARTS_WITH" and value.startswith(cmp): #equal
                indexes.append(i)

            elif condition == "ENDS_WITH" and value.endswitch(cmp): #endswith
                indexes.append(i)

    if is_verbose_mode_enabled():
        print(f"Filtered indexes: {indexes}")
    return indexes

def get_domain_attribute_values(obj, domain, attribute_name):
    """Gets values of attribute stored in domain like: edges[0].use_sharp 

    Args:
        obj (Reference): 3D Object Reference
        domain (str): Name of the domain: POINT EDGE FACE CORNER
        attribute_name (str): Name of the attribute to set eg. use_sharp

    Returns:
        list: A list of values in that attribute. The type of values in list is variable.
    """
    try:
        if domain== "POINT":
            print(f"getting {attribute_name} 0: {getattr(obj.data.vertices[0], attribute_name)}")
            return [getattr(v, attribute_name) for v in obj.data.vertices]
        elif domain == "EDGE":
            return  [getattr(v, attribute_name) for v in obj.data.edges]
        elif domain == "FACE":
            return [getattr(v, attribute_name) for v in obj.data.polygons]
        elif domain == "CORNER":
            return [getattr(v, attribute_name) for v in obj.data.loops]
    except Exception as e:
        raise etc.MeshDataReadException("get_domain_attribute_values", f"Failed to get {attribute_name} from {domain} \n {e}")

def get_mesh_data(obj, data_type, source_domain, **kwargs):
    """Gets all selected data from mesh.

    Args:
        obj (Reference): Object Reference
        data_type (str): The data type to fetch. See data.object_data_sources
        source_domain (str): The domain to take this data from

        kwargs: (if applicable)
        * vg_index              index of vertex group [id]
        * sk_index              index of shape key [id]
        * vg_offset_index       index of vertex group and the vertex group to offset from [id1, id2]
        * fm_index              face map index
        * sel_mat               selected material
        * mat_index             material index
        * uvmap_index           uvmap index

    Raises:
        etc.MeshDataReadException: on failure if selected data type does not exist

    Returns:
        list: _All values. Might conatain tuples or multi level lists.
    """

    
    
    if is_verbose_mode_enabled():
        print(f"get_mesh_data_kwargs: {kwargs}")
        print(f"Reading {data_type} mesh data on {source_domain}...")

    # DOMAIN INDEX
    if data_type == "INDEX":

        if source_domain == "POINT":
            return [i for i, vert in enumerate(obj.data.vertices)]

        elif source_domain == "EDGE":
            return [i for i, edge in enumerate(obj.data.edges)]

        elif source_domain == "FACE":
            return [i for i, face in enumerate(obj.data.polygons)]

        elif source_domain == "CORNER":
            return [i for i, corner in enumerate(obj.data.loops)]
        
    # VISIBILITY IN EDIT MODE
    elif data_type == "VISIBLE":
        return [not val for val in get_domain_attribute_values(obj, source_domain, "hide")]

    # SELECTED
    elif data_type == "SELECTED":
        return get_domain_attribute_values(obj, source_domain, "select")

    # NOT SELECTED
    elif data_type == "NOT_SELECTED":
        return [not val for val in get_domain_attribute_values(obj, source_domain, "select")]
 
    # POSITION
    elif data_type == "POSITION":
        if source_domain == 'POINT':
            return get_domain_attribute_values(obj, source_domain, "co")
        
        elif source_domain == 'EDGE':
            pairs = get_domain_attribute_values(obj, source_domain, "vertices")
            storage = []
            for i, vert_pair in enumerate(pairs):
                pos_0 = obj.data.vertices[vert_pair[0]].co
                pos_1 = obj.data.vertices[vert_pair[1]].co
                edge_pos = (pos_0 + pos_1)/2
                storage.append(edge_pos)
            return storage

        elif source_domain == 'FACE':
            return [val for val in get_domain_attribute_values(obj, source_domain, "center")]

    # NORMALS
    elif data_type == "NORMAL":
        if source_domain == "POINT":
            return [vec.vector for vec in obj.data.vertex_normals]
            
        elif source_domain == "FACE":
            return [vec.vector for vec in obj.data.polygon_normals]
    
    # CUSTOM SPLIT NORMALS
    elif data_type == "SPLIT_NORMALS":
            return get_domain_attribute_values(obj, source_domain, "normal")

    # VERTEX MESH ATTRIBUTES START
    # -----------------------------

    # VERTEX MEAN BEVEL
    elif data_type == "VERT_MEAN_BEVEL":
        
        if hasattr(obj.data.vertices, "bevel_weight"):
            return get_domain_attribute_values(obj, source_domain, "bevel_weight")
        else:
            if not "bevel_weight_vert" in obj.data.attributes:
                return [0.0] * len(obj.data.vertices)
            else:
                return [bevel.value for bevel in obj.data.attributes["bevel_weight_vert"].data]


    # VERTEX MEAN CREASE
    elif data_type == "VERT_MEAN_CREASE":
        if bpy.app.version < (4,0):
            if not len(obj.data.vertex_creases):
                return [0.0] * len(obj.data.vertices)
            else:
                return [crease.value for crease in obj.data.vertex_creases[0].data]
        else:
            if not "vertex_creases" in obj.data.attributes:
                return [0.0] * len(obj.data.vertices)
            else:
                return [crease.value for crease in obj.data.attributes["vertex_creases"].data.values()]
    
    # SCULPT MODE MASK ON VERTEX
    elif data_type == "SCULPT_MODE_MASK":
        if not len(obj.data.vertex_paint_masks):
            return [0.0] * len(obj.data.vertices)
        else:
            return [mask.value for mask in obj.data.vertex_paint_masks[0].data]
        
    # VERT_IS_IN_VERTEX_GROUP
    elif data_type == "VERT_IS_IN_VERTEX_GROUP":        
        vg = obj.vertex_groups[int(kwargs['vg_index'])]
        data = []

        for vert in obj.data.vertices:
            b_is_in_group = False
            for group in vert.groups:
                if group.group == int(kwargs['vg_index']):
                    b_is_in_group = True
                    break
            data.append(b_is_in_group)
        return data
    
    # VERTEX GROUP VALUE
    elif data_type == "VERT_FROM_VERTEX_GROUP" :        
        vg = obj.vertex_groups[int(kwargs['vg_index'])]
        data = []

        for vert in obj.data.vertices:
            weight = 0.0
            
            for group in vert.groups:
                if group.group == int(kwargs['vg_index']):
                    weight = group.weight
                    break
            data.append(weight)

        return data

    # VERT_SHAPE_KEY_POSITION
    elif data_type == "VERT_SHAPE_KEY_POSITION":
        sk = obj.data.shape_keys.key_blocks[int(kwargs['sk_index'])]
        return [vert.co for vert in sk.data]

    # VERT SHAPE KEY OFFSET
    elif data_type == "VERT_SHAPE_KEY_POSITION_OFFSET":
        sk = obj.data.shape_keys.key_blocks[int(kwargs['sk_index'])]
        offset_from = [vert_shape.co for vert_shape in sk.data]

        offset_sk = obj.data.shape_keys.key_blocks[int(kwargs['sk_offset_index'])]
        offset_to = [vert_shape.co for vert_shape in offset_sk.data]
        
        for vert in obj.data.vertices:
            offset_from[vert.index] = offset_to[vert.index] - offset_from[vert.index]
        return offset_from


    # EDGE MESH ATTRIBUTES START
    # -----------------------------

    # EDGE SEAM
    elif data_type == "EDGE_SEAM":
        return get_domain_attribute_values(obj, source_domain, "use_seam") 
        
    # EDGE BEVEL WEIGHT
    elif data_type == "EDGE_BEVEL_WEIGHT":
 
        if hasattr(obj.data.vertices, "bevel_weight"):
            return get_domain_attribute_values(obj, source_domain, "bevel_weight")
        else:
            if not "bevel_weight_edge" in obj.data.attributes:
                return [0.0] * len(obj.data.edges)
            else:
                return [bevel.value for bevel in obj.data.attributes["bevel_weight_edge"].data]
    
    # EDGE CREASE
    elif data_type == "EDGE_CREASE":
        if bpy.app.version < (4,0):
            return get_domain_attribute_values(obj, source_domain, "crease") 
        else:
            if not "edge_creases" in obj.data.attributes:
                return [0.0] * len(obj.data.edges)
            else:
                return [crease.value for crease in obj.data.attributes["edge_creases"].data.values()]
        
    # EDGE SHARP
    elif data_type == "EDGE_SHARP":
        if hasattr(obj.data.edges, "use_sharp"):
            return get_domain_attribute_values(obj, source_domain, "use_sharp")
        elif hasattr(obj.data.edges, "use_edge_sharp"):
            return get_domain_attribute_values(obj, source_domain, "use_edge_sharp")
        else:
            if not "sharp_edge" in obj.data.attributes:
                return [False] * len(obj.data.edges)
            else:
                return [sharp.value for sharp in obj.data.attributes["sharp_edge"].data]
        
        
    # EDGE FREESTYLE MARK
    elif data_type == "EDGE_FREESTYLE_MARK":
        return get_domain_attribute_values(obj, source_domain, "use_freestyle_mark") 
        
    # EDGE IS LOOSE
    elif data_type == "EDGE_IS_LOOSE":
        return get_domain_attribute_values(obj, source_domain, "is_loose") 
        
    # EDGE_VERTICES
    elif data_type == "EDGE_VERTICES":
        return get_domain_attribute_values(obj, source_domain, "vertices") 
        
    # FACE MESH ATTRIBUTES START
    # -----------------------------

    # SCULPT MODE FACE SETS IDS
    elif data_type == "SCULPT_MODE_FACE_SETS":
        if bpy.app.version < (4,0):
            # case: no face sets
            if ".sculpt_face_set" not in obj.data.polygon_layers_int:
                return [0] * len(obj.data.polygons)
            else:
                return [face.value for face in obj.data.polygon_layers_int['.sculpt_face_set'].data]
        else:
            if not ".sculpt_face_set" in obj.data.attributes:
                return [0] * len(obj.data.polygons)
            else:
                return [faceset.value for faceset in obj.data.attributes[".sculpt_face_set"].data]
        
    # FACE_AREA
    elif data_type == "FACE_AREA":
        return get_domain_attribute_values(obj, source_domain, "area") 
    
    # FACE IS SMOOTH SHADED
    elif data_type == "FACE_USE_SMOOTH":
        if not hasattr(obj.data.polygons[0], "use_smooth"):
            return get_domain_attribute_values(obj, source_domain, "use_smooth") 
        else: # futureproofing
            if not "sharp_face" in obj.data.attributes:
                return [False] * len(obj.data.polygons)
            else:
                return [faceset.value for faceset in obj.data.attributes["sharp_face"].data]

    # FACE MATERIAL INDEX
    elif data_type == "FACE_MATERIAL_INDEX":
        if not hasattr(obj.data.polygons[0], "material_index"):
            return get_domain_attribute_values(obj, source_domain, "material_index") 
        else: # futureproofing
            if not "material_index" in obj.data.attributes:
                return [0] * len(obj.data.polygons)
            else:
                return [faceset.value for faceset in obj.data.attributes["material_index"].data]
        
    # FACE VERTS
    elif data_type == "FACE_VERTS":
        return [f.vertices for f in obj.data.polygons]
        
    # FACE_CORNER_INDEXES
    elif data_type == "FACE_CORNER_INDEXES":
        return [f.loop_indices for f in obj.data.polygons]
    
    # FACE CORNER COUNT
    elif data_type == "FACE_CORNER_TOTAL":
        return get_domain_attribute_values(obj, source_domain, "loop_total") 

    # FACE CORNER START INDEX
    elif data_type == "FACE_CORNER_START_INDEX":
        return get_domain_attribute_values(obj, source_domain, "loop_start") 

    # FACE_FROM_FACE_MAP
    elif data_type == "FACE_FROM_FACE_MAP":
        # WARN: IF NO FACE MAP WAS SET THEN obj.data.face_maps len = 0, even if it was created in the properties panel...
        if len(obj.data.face_maps):
            # print(kwargs['fm_index'])
            # print([obj.data.face_maps[0].data[i].value for i, f in enumerate(obj.data.polygons)])
            return [obj.data.face_maps[0].data[i].value == int(kwargs['fm_index']) for i, f in enumerate(obj.data.polygons)]
        else:
            return [False] * len(obj.data.polygons)

    # FACE MAP INDEX
    elif data_type == "FACE_MAP_INDEX":
        if len(obj.data.face_maps):
            return [obj.data.face_maps[0].data[i].value for i, f in enumerate(obj.data.polygons)]
        else:
            return [-1] * len(obj.data.polygons)

    # FACE MATERIAL INDEX
    elif data_type == "FACE_IS_MATERIAL_ASSIGNED":
        # print(bpy.data.materials[int(kwargs['sel_mat'])])
        # print([obj.material_slots[f.material_index].material for f in obj.data.polygons])
        if len(obj.material_slots):
            return [obj.material_slots[f.material_index].material == bpy.data.materials[int(kwargs['sel_mat'])] for f in obj.data.polygons]
        else:
            return [False] * len(obj.data.polygons)

    #"FACE_IS_MATERIAL_SLOT_ASSIGNED",
    elif data_type == "FACE_IS_MATERIAL_SLOT_ASSIGNED":
        if len(obj.material_slots):
            return [f.material_index == int(kwargs['mat_index']) for f in obj.data.polygons]
        else:
            return [False] * len(obj.data.polygons)

    # FACE CORNER MESH ATTRIBUTES START
    # -----------------------------

    # TANGENT
    elif data_type == "CORNER_TANGENT":
        return get_domain_attribute_values(obj, source_domain, "tangent") 
        
    # BITANGENT
    elif data_type == "CORNER_BITANGENT":
        return get_domain_attribute_values(obj, source_domain, "bitangent") 
    
    # BITANGENT SIGN
    elif data_type == "CORNER_BITANGENT_SIGN":
        return get_domain_attribute_values(obj, source_domain, "bitangent_sign") 
        
    # EDGE INDEX
    elif data_type == "CORNER_EDGE_INDEX":
        return get_domain_attribute_values(obj, source_domain, "edge_index") 
        
    # VERTEX INDEX
    elif data_type == "CORNER_VERTEX_INDEX":
        return get_domain_attribute_values(obj, source_domain, "vertex_index") 
    
    # UVMAP
    elif data_type == "UVMAP":
        return [map.uv for map in obj.data.uv_layers[int(kwargs['uvmap_index'])].data]
    

    # -----------------------------
    # SPECIAL ATTRIBS START

    # SELECTED VERTS IN UV EDITOR
    elif data_type == "SELECTED_VERTICES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name
        return [vs.value for vs in obj.data.attributes[f".vs.{uvmap_name}"].data]
    
    # SELECTED EDGES IN UV EDITOR
    elif data_type == "SELECTED_EDGES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name
        return [es.value for es in obj.data.attributes[f".es.{uvmap_name}"].data]
    
    else:
        raise etc.MeshDataReadException("get_mesh_data", f"Invalid domain data type ({data_type}) or this data is not available on this domain ({source_domain})")

# set

def set_domain_attribute_values(obj, attribute_name:str, domain:str, values: list):
    """Sets values of attribute stored in domain like: edges[0].use_sharp 

    Args:
        obj (Reference): 3D Object Reference
        attribute_name (str): Name of the attribute
        domain (str): Attribute Domain
        values (list): Values to set 
    """

    if domain == 'POINT':
        for i, vert in enumerate(obj.data.vertices):
            setattr(vert, attribute_name, values[i])
    elif domain == 'EDGE':
        for i, edge in enumerate(obj.data.edges):
            setattr(edge, attribute_name, values[i])
    elif domain == 'FACE':
        for i, face in enumerate(obj.data.polygons):
            setattr(face, attribute_name, values[i])
    elif domain == 'CORNER':
        for i, loop in enumerate(obj.data.loops):
            setattr(loop, attribute_name, values[i])

def set_selection_or_visibility_of_mesh_domain(obj, domain, indexes, state = True, selection = True):
    """Sets the selection or visibility in edit mode.
    Those require setting the state of faces, edges and vertices separately, hence the separate function.

    Args:
        obj (Reference ): 3D Object Reference
        domain (str): Domain - POINT EDGE FACE CORNER
        indexes (list): Domain indexes to set the state
        state (bool, optional): The state of visibility or selection. Defaults to True.
        selection (bool, optional): Whether toggle selection or visibility. Defaults to True.

    Raises:
        Exception: On failure, re-raises the exception and clears bmesh
    """
    if is_verbose_mode_enabled():
        print(f"Setting sel/vis {selection} to state  {state} on {domain}, \ndataset {indexes}")

    bm = bmesh.new()
    bm.from_mesh(obj.data)
    bm.verts.ensure_lookup_table()
    bm.edges.ensure_lookup_table()
    bm.faces.ensure_lookup_table()
    if domain != 'CORNER':
        try:
            if domain == 'POINT':
                for vertindex in indexes:
                    if selection:
                        bm.verts[vertindex].select = state
                    else:
                        bm.verts[vertindex].hide = state

                    for edge in bm.verts[vertindex].link_edges:
                        if state == selection:
                            if all(vert.index in indexes for vert in edge.verts):
                                if selection:
                                    edge.select = state
                                else:
                                    edge.hide = state
                        else:
                            if any(vert.index in indexes for vert in edge.verts):
                                if selection:
                                    edge.select = state
                                else:
                                    edge.hide = state

                    for face in bm.verts[vertindex].link_faces:
                        if state == selection:
                            if all(vert.index in indexes for vert in face.verts):
                                if selection:
                                    face.select = state
                                else:
                                    face.hide = state
                        else:
                            if any(vert.index in indexes for vert in face.verts):
                                if selection:
                                    face.select = state
                                else:
                                    face.hide = state

            elif domain == 'EDGE':
                for edgeindex in indexes:
                    if selection:
                        bm.edges[edgeindex].select = state
                    else:
                        bm.edges[edgeindex].hide = state

                    for vert in bm.edges[edgeindex].verts:
                        if selection:
                            vert.select = state
                        else:
                            vert.hide = state
                
                    for face in bm.edges[edgeindex].link_faces:
                        if state == selection:
                            if all(edge.index in indexes for edge in face.edges):
                                if selection:
                                    face.select = state
                                else:
                                    face.hide = state
                        else:
                            if any(edge.index in indexes for edge in face.edges):
                                if selection:
                                    face.select = state
                                else:
                                    face.hide = state
                    
            elif domain == 'FACE':
                for faceindex in indexes:
                    if selection:
                        bm.faces[faceindex].select = state
                    else:
                        bm.faces[faceindex].hide = state

                    for vert in bm.faces[faceindex].verts:
                        if selection:
                            vert.select = state
                        else:
                            vert.hide = state
                    
                    for edge in bm.faces[faceindex].edges:
                        if selection:
                            edge.select = state
                        else:
                            edge.hide = state
            
            bm.to_mesh(obj.data)
            bm.free()
        except Exception as e:
            # clear bmesh on exception to avoid extra problems
            bm.to_mesh(obj.data)
            bm.free()
            raise Exception(e)

    else:
        edge_indexes_to_select = []

        for cornerindex in indexes:
            loop = obj.data.loops[cornerindex]

            # get the face index that has this corner
            faceindex = -1
            for face in bm.faces:
                if cornerindex in [loop.index for loop in face.loops]:
                    faceindex = face.index
            
            # get edges that are connected to vertex assinged to this corner
            edges = bm.verts[loop.vertex_index].link_edges
            if is_verbose_mode_enabled():
                print(f"loop {cornerindex} has edges {[edge.index for edge in edges]}")
                print(f"loop {cornerindex} has a face {faceindex}, with edges {[edge.index for edge in bm.faces[faceindex].edges]}")
            
            # get edges that are in face index of this corner
            for edge in edges:
                if edge in bm.faces[faceindex].edges:
                    edge_indexes_to_select.append(edge.index)
        
        bm.free()
        if is_verbose_mode_enabled():
            print(f"Filtered edges of the corner are {edge_indexes_to_select}")
        set_selection_or_visibility_of_mesh_domain(obj, 'EDGE', edge_indexes_to_select, state, selection)


def set_mesh_data(obj, data_target:str , src_attrib, **kwargs):
    """Sets mesh data from selected attribute

    Args:
        obj (Reference): 3D Object Reference
        data_target (str): See data.object_data_targets
        src_attrib (Reference): Attribute reference
        
        kwargs: (If applicable)
        * face_map_name             Name of the face map to create
        * vertex_group_name         Name of the vertex group to create
        * enable_auto_smooth        bool
        * apply_to_first_shape_key  bool
        * to_vgindex_weight         float
        * to_vgindex_weight_mode    enum - STATIC, ATTRIBUTE
        * to_vgindex_src_attrib     attribute reference
        * uvmap_index               integer
        * invert_sculpt_mask        boolean, 1-clamped sculpt mask val
        * expand_sculpt_mask_mode   enum REPLACE EXPAND SUBTRACT

    Raises:
        etc.MeshDataWriteException: On failure if selected data target is not supported

    Returns:
        Nothing
    """
    
    a_vals = get_attrib_values(src_attrib, obj)
    if is_verbose_mode_enabled():
        print(f"Setting mesh data {data_target} from {src_attrib}, values: {a_vals}, kwargs: {kwargs}")
    
    src_attrib_name = src_attrib.name

    # QUICK BOOLEANS
    # -----------------------------

    # TO VISIBLE
    if data_target == "TO_VISIBLE":
        vis_indexes = [index for index, value in enumerate(a_vals) if value]
        set_selection_or_visibility_of_mesh_domain(obj, src_attrib.domain, vis_indexes, False, selection=False)

    # TO HIDDEN
    elif data_target == "TO_HIDDEN":
        hid_indexes = [index for index, value in enumerate(a_vals) if value]
        set_selection_or_visibility_of_mesh_domain(obj, src_attrib.domain, hid_indexes, True, selection=False)

    # TO SELECTED
    elif data_target == "TO_SELECTED":
        sel_indexes = [index for index, value in enumerate(a_vals) if value]
        set_selection_or_visibility_of_mesh_domain(obj, src_attrib.domain, sel_indexes, True)

    # TO NOT SELECTED
    elif data_target == "TO_NOT_SELECTED":
         nsel_indexes = [index for index, value in enumerate(a_vals) if value]
         set_selection_or_visibility_of_mesh_domain(obj, src_attrib.domain, nsel_indexes, False)


    # VERTEX MESH DATA
    # -----------------------------

    # TO VERTEX GROUP INDEX
    elif data_target == "TO_VERTEX_GROUP_INDEX":
    
        # clamp to max index
        max_index_input = max(a_vals)
        max_index_target = len(obj.vertex_groups) - 1
        max_index = max(min([max_index_input, max_index_target]), 0)
        
        if kwargs["to_vgindex_weight_mode"] == 'STATIC':
            #lazy set the weight to static value
            for i, val in enumerate(a_vals):
                obj.vertex_groups[min([max_index, max(val,0)])].add([i], kwargs['to_vgindex_weight'], 'REPLACE')
        
        # or use attrib
        elif kwargs["to_vgindex_weight_mode"] == 'ATTRIBUTE':
            for i, val in enumerate(a_vals):
                
                obj.vertex_groups[min([max_index, max(val,0)])].add([i], kwargs['to_vgindex_src_attrib'].data[i].value, 'REPLACE')

    # TO SCULPT MODE MASK
    elif data_target == "TO_SCULPT_MODE_MASK":

        # case: no mask layer, user never used mask on this mesh
        if not len(obj.data.vertex_paint_masks):
            src_attrib_name = src_attrib.name
            # I have not found a way to create a mask layer without using bmesh, so here it goes
            bm = bmesh.new()
            bm.from_mesh(obj.data)
            bm.verts.layers.paint_mask.verify()
            bm.to_mesh(obj.data)
            bm.free()
            src_attrib = obj.data.attributes[src_attrib_name] # !important
        
        for i, val in enumerate(a_vals):
            val = min(max(val, 0.0), 1.0)

            # Invert the values if enabled
            if kwargs['invert_sculpt_mask']:
                val = 1.0 - val

            # Apply different value depending on the mode (auto clamped then)
            if kwargs['expand_sculpt_mask_mode'] == 'REPLACE':
                obj.data.vertex_paint_masks[0].data[i].value = val
            elif kwargs['expand_sculpt_mask_mode'] == 'EXPAND':
                obj.data.vertex_paint_masks[0].data[i].value += val
            elif kwargs['expand_sculpt_mask_mode'] == 'SUBTRACT':
                obj.data.vertex_paint_masks[0].data[i].value -= val
        
    # TO VERTEX GROUP
    elif data_target == "TO_VERTEX_GROUP":
        name = get_safe_attrib_name(obj, src_attrib_name + " Group", 'Group')
        vg = obj.vertex_groups.new(name=name if kwargs["vertex_group_name"] == '' else kwargs["vertex_group_name"])
        for vert in obj.data.vertices:
            weight = a_vals[vert.index]
            vg.add([vert.index], weight, 'REPLACE')

    # TO POSITION
    elif data_target == "TO_POSITION":
        set_domain_attribute_values(obj, 'co', src_attrib.domain, a_vals) 

        # Apply to first shape key too, if enabled
        if hasattr(obj.data.shape_keys, 'key_blocks') and kwargs["apply_to_first_shape_key"]:
            sk = obj.data.shape_keys.key_blocks[obj.data.shape_keys.key_blocks.keys()[0]].data
            for i, val in enumerate(a_vals):
                sk[i].co = val

    # TO SHAPE KEY
    elif data_target == "TO_SHAPE_KEY":
        sk = obj.shape_key_add(name=src_attrib_name)
        l = [[vec[0],vec[1],vec[2]] for vec in a_vals]
        for vert in obj.data.vertices:
            sk.data[vert.index].co = l[vert.index]

    # VERTEX & EDGE MESH DATA
    # -----------------------------

    # TO MEAN BEVEL WEIGHT
    elif data_target == "TO_MEAN_BEVEL_WEIGHT":
        if hasattr(obj.data.vertices, 'bevel_weight'): # Works for edges too, as the api change happened for both at once.
            set_domain_attribute_values(obj, 'bevel_weight', src_attrib.domain, a_vals) 
        else:
            if src_attrib.domain == 'POINT':
                if not "bevel_weight_vert" in obj.data.attributes:
                    obj.data.attributes.new("bevel_weight_vert", 'FLOAT', 'POINT')
                set_attribute_values(obj.data.attributes["bevel_weight_vert"], a_vals)

            elif src_attrib.domain == 'EDGE':
                if not "bevel_weight_edge" in obj.data.attributes:
                    obj.data.attributes.new("bevel_weight_edge", 'FLOAT', 'EDGE')
                set_attribute_values(obj.data.attributes["bevel_weight_edge"], a_vals)
        
    # TO MEAN CREASE
    elif data_target == "TO_MEAN_CREASE":
        if src_attrib.domain == 'POINT':
            if bpy.app.version < (4,0):
                
                # Create layer if it does not exist:
                if not len(obj.data.vertex_creases):
                    bm = bmesh.new()
                    bm.from_mesh(obj.data)
                    bm.verts.layers.crease.verify()
                    bm.to_mesh(obj.data)
                    bm.free()
                for i, val in enumerate(a_vals):
                    obj.data.vertex_creases[0].data[i].value = val
            else:
                if not "vertex_creases" in obj.data.attributes:
                    obj.data.attributes.new("vertex_creases", 'FLOAT', 'POINT')
                
                set_attribute_values(obj.data.attributes["vertex_creases"], a_vals)
                
        elif src_attrib.domain == 'EDGE':
            if bpy.app.version < (4,0):
                set_domain_attribute_values(obj, 'crease', src_attrib.domain, a_vals) 
            else:
                if not "edge_creases" in obj.data.attributes:
                    obj.data.attributes.new("edge_creases", 'FLOAT', 'EDGE')
                set_attribute_values(obj.data.attributes["edge_creases"], a_vals)
   
    # EDGE MESH DATA
    # -----------------------------

    # TO EDGE SEAM
    elif data_target == "TO_SEAM":
        set_domain_attribute_values(obj, 'use_seam', src_attrib.domain, a_vals) 

    # TO EDGE SHARP
    elif data_target == "TO_SHARP":
        if len(obj.data.edges):
            if hasattr(obj.data.edges[0], "use_sharp"):
                set_domain_attribute_values(obj, "use_sharp", src_attrib.domain, a_vals) 
            elif hasattr(obj.data.edges[0], "use_edge_sharp"):
                set_domain_attribute_values(obj, 'use_edge_sharp', src_attrib.domain, a_vals) 

    # TO FREESTYLE MARK
    elif data_target == "TO_FREESTYLE_MARK":
        set_domain_attribute_values(obj, 'use_freestyle_mark', src_attrib.domain, a_vals) 

    # FACE MESH DATA
    # -----------------------------

    # TO FACE MAP
    elif data_target == "TO_FACE_MAP":
        fm_name = "Face Map" if kwargs["face_map_name"] == '' else kwargs["face_map_name"]
        fm = obj.face_maps.new(name=fm_name)
        
        # create layer
        bm = bmesh.new()
        bm.from_mesh(obj.data)
        bm.faces.layers.face_map.verify()
        bm.to_mesh(obj.data)
        bm.free()

        # Set face map index to selected polygons in attribute (True)
        for i, val in enumerate(a_vals):
            if val:
                obj.data.face_maps[0].data[i].value = fm.index

    # TO SHADE SMOOTH
    elif data_target == "TO_FACE_SHADE_SMOOTH":
        set_domain_attribute_values(obj, 'use_smooth', src_attrib.domain, a_vals) 
    
    # TO SCULPT MODE FACE SETS
    elif data_target == "TO_SCULPT_MODE_FACE_SETS":
        # case: no face sets
        if ".sculpt_face_set" not in obj.data.polygon_layers_int:
            obj.data.polygon_layers_int.new(name=".sculpt_face_set" )

        for i, val in enumerate(a_vals):
            obj.data.polygon_layers_int['.sculpt_face_set'].data[i].value = val
    
    # TO MATERIAL INDEX
    elif data_target == "TO_MATERIAL_SLOT_INDEX":
        if len(obj.data.polygons):
            
            if hasattr(obj.data.polygons[0], 'material_index'):
                if max_index > 0:
                    set_domain_attribute_values(obj, 'material_index', src_attrib.domain, a_vals) 

            else: # futureproofing
                max_index = max((len(obj.material_slots)-1), 0)
                if not 'material_index' in obj.data.attributes:
                    obj.data.attributes.new('material_index', 'INT', 'FACE')
                set_attribute_values(obj.data.attributes['material_index'], a_vals)
    
    # TO FACE MAP INDEX
    elif data_target == "TO_FACE_MAP_INDEX":
        for i, val in enumerate(a_vals):
            # limit the value
            val = max(0, min(val, len(obj.face_maps)-1))
            obj.data.face_maps[0].data[i].value = val

    # FACE CORNER MESH DATA
    # -----------------------------

    # TO SPLIT NORMALS
    elif data_target == 'TO_SPLIT_NORMALS':
        obj.data.use_auto_smooth = kwargs['enable_auto_smooth']
        if src_attrib.domain == 'POINT':
            obj.data.normals_split_custom_set_from_vertices([[vec[0],vec[1],vec[2]] for vec in a_vals])
        elif src_attrib.domain == 'CORNER':
            obj.data.normals_split_custom_set([[vec[0],vec[1],vec[2]] for vec in a_vals])
    
    # TO UV MAP
    elif data_target == "TO_UVMAP":
        obj.data.uv_layers.new(name=src_attrib_name)
        for i, val in enumerate(a_vals):
            obj.data.uv_layers[int(kwargs['uvmap_index'])].data[i].uv = (val[0], val[1])

    # UV EDITOR SPECIALS
    # -----------------------------

    # TO SELECTED VERTICES IN UV EDITOR
    elif data_target == "TO_SELECTED_VERTICES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name

        for i, val in enumerate(a_vals):
            obj.data.attributes[f'.vs.{uvmap_name}'].data[i].value = val

    # TO SELECTED EDGES IN UV EDITOR
    elif data_target == "TO_SELECTED_EDGES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name

        for i, val in enumerate(a_vals):
            obj.data.attributes[f'.es.{uvmap_name}'].data[i].value = val

    # TO PINNED VERTICES IN UV EDITOR
    elif data_target == "TO_PINNED_VERTICES_IN_UV_EDITOR":
        uvmap_name = obj.data.uv_layers[int(kwargs['uvmap_index'])].name

        if not '.pn.{uvmap_name}' in obj.data.attributes:
            obj.data.attributes.new('.es.{uvmap_name}', 'BOOLEAN', 'CORNER')

        for i, val in enumerate(a_vals):
            obj.data.attributes[f'.pn.{uvmap_name}'].data[i].value = val

    # NONE OF ABOVE
    # -----------------------------
    else:
        raise etc.MeshDataWriteException("set_mesh_data", f"Can't find {data_target} to set")
          
def get_all_mesh_data_entries_of_type(obj,data_type):
    """Gets all indexes of iterable mesh data. Used in batch converting of attributes.

    * Vertex Groups
    * Shape Keys
    * Face Maps
    * Material Slots

    Args:
        obj (Reference): 3D Object Reference
        data_type (str): Namedtuple entry names, see data.object_data_sources

    Returns:
        list: of all indexes
    """

    if data_type in ["VERT_IS_IN_VERTEX_GROUP", "VERT_FROM_VERTEX_GROUP"]:   
        return [vg.index for vg in obj.vertex_groups]     

    elif data_type in ["VERT_SHAPE_KEY_POSITION" , "VERT_SHAPE_KEY_POSITION_OFFSET"]:
        return [i for i, sk in enumerate(obj.data.shape_keys.key_blocks)]

    elif data_type == "FACE_FROM_FACE_MAP":
        return list(set([obj.data.face_maps[0].data[i].value  for i, f in enumerate(obj.data.polygons)]))

    elif data_type in ["FACE_IS_MATERIAL_SLOT_ASSIGNED"]:
        return [i for i, mat_slot in obj.material_slots]

    elif data_type in ["FACE_IS_MATERIAL_ASSIGNED"]:
            return [f.material_index for f in obj.data.polygons]


# ------------------------------------------
# Utility

def get_friendly_domain_name(domain_name_raw, plural=False):
    """Converts internal domain name to friendly name to be used in UI
    eg. CORNER to Face Corners

    Args:
        domain_name_raw (str): Domain name
        plural (bool, optional): Return plural string. Defaults to False.

    Returns:
        str: Friendly string
    """
    if domain_name_raw == 'POINT':
        return "Vertex" if not plural else "Vertices"
    elif domain_name_raw == 'CORNER':
        return "Face Corner" if not plural else "Face Corners"
    else:
        return domain_name_raw.lower().capitalize() if not plural else domain_name_raw.lower().capitalize() + "s"

def get_friendly_data_type_name(data_type_raw):
    """Gets friendly name for attribute data types, to use it in GUI
    eg. INT8 -> 8-bit Integer. See data.attribute_data_types
    Args:
        data_type_raw (str): Data type

    Returns:
        str: Friendly string
    """
    if data_type_raw in data.attribute_data_types:
        return data.attribute_data_types[data_type_raw].friendly_name
    else:
        return data_type_raw

# Data enums
# --------------------------------------------

# individual mesh data enums
def get_face_maps_enum(self, context):
    """Gets all face maps as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []
    obj = bpy.context.active_object

    # case: no data
    if not hasattr(obj, 'face_maps') or not len(obj.face_maps):
        return [("NULL", "[!] No face maps", "")]


    for face_map in obj.face_maps:
        items.append((str(face_map.index), face_map.name, f"Use {face_map.name} face map "))

    return items

def get_material_slots_enum(self, context):
    """Gets all material slots in active object as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """
    items = []
    obj = bpy.context.active_object

    # case: no data
    if not len(obj.material_slots):
        return [("NULL", "[!] No material slots", "")]

    for i, material_slot in enumerate(obj.material_slots):
        if material_slot is not None:
            material_slot_name = f"{str(i)}. {material_slot.name if material_slot.name != '' else 'Empty Slot'}"
            items.append((str(i), material_slot_name, f"Use {material_slot_name} material slot"))

    return items

def get_materials_enum(self, context):
    """Gets all materials stored in blend file as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []

    # case: no data
    if not len(bpy.data.materials):
        return [("NULL", "[!] No materials", "")]


    for i, material in enumerate(bpy.data.materials):
        if material is not None:
            items.append((str(i), material.name, f"Use {material.name} material"))

    return items

def get_vertex_groups_enum(self, context):
    """Gets all vertex groups of active object as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []
    obj = bpy.context.active_object

    # case: no data
    if not len(obj.vertex_groups):
        return [("NULL", "[!] No Vertex Groups", "")]

    for vg in obj.vertex_groups:
        items.append((str(vg.index), vg.name, f"Use {vg.name} vertex group"))

    return items

def get_shape_keys_enum(self, context):
    """Gets all shape keys of active object as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []
    obj = bpy.context.active_object

    # case: no data
    if obj.data.shape_keys is None:
        return [("NULL", "[!] No Shape Keys", "")]

    for i, sk in enumerate(obj.data.shape_keys.key_blocks):
        items.append((str(i), sk.name, f"Use {sk.name} shape key"))

    return items

def get_uvmaps_enum(self, context):
    """Gets all UVMaps of active object as an enum entries.
    
    Can be 'NULL' if there is none.

    List entries will be tuples formatted as (INDEX NAME DESC)

    Args:
        context (Reference): Blender Context Reference

    Returns:
        list: List of tuples to be used as enum values
    """

    items = []
    obj = context.active_object

    # case: no data
    if not len(obj.data.uv_layers):
        return [("NULL", "NO UVMAPS", "")]


    for i, uvmap in enumerate(obj.data.uv_layers):
        items.append((str(i), uvmap.name, f"Use {uvmap.name} UVMap"))

    return items

# extra gui enums

def get_supported_domains_for_selected_mesh_data_source_enum_entry(self, context):
    """Gets aa list of compatible domains from enum selection in self.domain_data_type, for reading or writing mesh data from object

    Example being mean bevel that can be stored either in edges or vertices.

    [!] self object has to have domain_data_type enum enum property.

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    items = []
    domains_supported = data.object_data_sources[self.domain_data_type_enum].domains_supported

    
    if 'POINT' in domains_supported:
        items.append(("POINT", "Vertex", "Use vertex domain for data type"))
    if 'EDGE' in domains_supported:
        items.append(("EDGE", "Edge", "Use edge domain for data type"))
    if 'FACE' in domains_supported:
        items.append(("FACE", "Face", "Use face domain for data type"))
    if 'CORNER' in domains_supported:
        items.append(("CORNER", "Face Corner", "Use face corner domain for data type"))

    return items

def get_mesh_data_enum_entry_icon(data_item):
    """Sets the enum entry icon. Fallbacks to default icon if none is set.

    Args:
        data_item (Reference): Reference to namedtuple from data.object_data_sources or data.object_data_targets

    Returns:
        str: The icon string
    """
    # set the default icon based on supported domains, if none is set
    if data_item.icon == "":
        domains = data_item.domains_supported
        if len(domains) > 1:
            icon = "MATCUBE"
        elif domains[0] == "POINT":
            icon = "VERTEXSEL"
        elif domains[0] == "EDGE":
            icon = "EDGESEL"
        elif domains[0] == "FACE":
            icon = "FACESEL"
        elif domains[0] == "CORNER":
            icon = "SNAP_PERPENDICULAR"
    else:
        icon = data_item.icon
    return icon

def get_source_data_enum(self, context, include_separators=True):
    """Gets enum entries for source data selection to create an attribute from. Contains separators and newlines.

    Args:
        context (Reference): Blender context reference
        include_separators (bool): Whether to include newlines and separators for enum dropdown menu 

    Returns:
        list: List of tuples to be used as enum entries
    """
    e = []
    for i, item in enumerate(data.object_data_sources):
        if "INSERT_SEPARATOR" in item and include_separators:
            e.append((None))
        elif "INSERT_NEWLINE" in item and include_separators:
             e.append(("","","","",i))
        else:
            minver = data.object_data_sources[item].min_blender_ver
            unsupported_from = data.object_data_sources[item].unsupported_from_blender_ver

            if etc.get_enhanced_enum_titles_enabled():
                name = data.object_data_sources[item].enum_gui_friendly_name
            else:
                name = data.object_data_sources[item].enum_gui_friendly_name_no_special_characters
            
            if etc.get_blender_support(minver, unsupported_from): 
                icon = get_mesh_data_enum_entry_icon(data.object_data_sources[item])
                e.append((item, name, data.object_data_sources[item].enum_gui_description, icon, i))
    return e

def get_source_data_enum_with_separators(self, context):
    return get_source_data_enum(self, context, include_separators=True)

def get_source_data_enum_without_separators(self, context):
    return get_source_data_enum(self, context, include_separators=False)

def get_target_data_enum(self, context, include_separators=True):
    """Gets enum entries for target data to store data from attribute. Contains separators and newlines.

    Args:
        context (Reference): Blender context reference
        include_separators (bool): Whether to include newlines and separators for enum dropdown menu 

    Returns:
        list: List of tuples to be used as enum entries
    """
    items = []
    obj = context.active_object
    active_attrib = obj.data.attributes.active
    inv_data_entry = ("NULL", "[!] No Convertable Data", "")


    for i, entry in enumerate(data.object_data_targets):
        if "INSERT_SEPARATOR" in entry and include_separators:
            items.append((None))
        elif "INSERT_NEWLINE" in entry and include_separators:
            items.append(("","","","",i))
        else:
            minver = data.object_data_targets[entry].min_blender_ver
            unsupported_from = data.object_data_targets[entry].unsupported_from_blender_ver

            if etc.get_blender_support(minver, unsupported_from): 
                icon = get_mesh_data_enum_entry_icon(data.object_data_targets[entry])
                item = (entry,
                        data.object_data_targets[entry].enum_gui_friendly_name, 
                        data.object_data_targets[entry].enum_gui_description,
                        icon,
                        i
                        )
                items.append(item)

    # this should not happen but since it is already coded here...
    if not len(items):
        return [inv_data_entry]
    
    return items

def get_target_data_enum_with_separators(self, context):
    return get_target_data_enum(self, context, include_separators=True)

def get_target_data_enum_without_separators(self, context):
    return get_target_data_enum(self, context, include_separators=False)

def get_supported_domains_for_selected_mesh_data_target_enum_entry(self, context):
    """Gets all compatible domains for selected data type as enum entries. 

    Example being mean bevel that can be stored either in edges or vertices.

    [!] self object has to have data_target_enum enum property.

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """

    domains_supported = data.object_data_targets[self.data_target_enum].domains_supported
    items = []

    if 'POINT' in domains_supported:
        items.append(("POINT", "Vertex", "Store this data in vertices"))
    if 'EDGE' in domains_supported:
        items.append(("EDGE", "Edge", "Store this data in edges"))
    if 'FACE' in domains_supported:
        items.append(("FACE", "Face", "Store this data in faces"))
    if 'CORNER' in domains_supported:
        items.append(("CORNER", "Face Corner", "Store this data in face corners"))
    
    return items

def get_attribute_data_types_enum(self,context):
    """Gets all attribute data types that are supported by current blender version as enum entries

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    l = []  
    for item in data.attribute_data_types:
        if etc.get_blender_support(data.attribute_data_types[item].min_blender_ver, data.attribute_data_types[item].unsupported_from_blender_ver):
            l.append((item, data.attribute_data_types[item].friendly_name, ""))
    return l

def get_attribute_domains_enum(self, context):
    """Gets all attribute domains that are supported by current blender version as enum entries

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    l = []
    for item in data.attribute_domains:
        if etc.get_blender_support(data.attribute_domains[item].min_blender_ver, data.attribute_domains[item].unsupported_from_blender_ver):
            l.append((item, data.attribute_domains[item].friendly_name, ""))
    return l

def get_attribute_invert_modes(self, context):
    """Returns a list of available modes to invert the active attribute, as enum entries.

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """

    dt = context.active_object.data.attributes.active.data_type

    # Check if this data is supported by the addon
    if not dt in data.attribute_data_types.keys():
        return[('NULL', "Data Type Unsupported", "")]
    
    # Get each supported mode to invert this attribute
    l = []
    for item in data.attribute_data_types[dt].supported_attribute_invert_modes:
        l.append((item, data.attribute_invert_modes[item].friendly_name, data.attribute_invert_modes[item].description))

    return l

def get_convert_attribute_modes_enum(self, context):
    """Gets all attribute convert modes

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    return data.attribute_convert_modes

def get_vertex_weight_attributes_enum(self, context):
    """Gets all attributes to syue as weight attribute when setting to vertex group index

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    return get_attributes_of_data_type_enum(self, context, ['FLOAT'])

def get_attributes_of_data_type_enum(self, context, data_types):
    """Gets all attributes by data type to use in enum dropdown.

    Args:
        context (Reference): Blender context reference
        data_types (list of str): All data type names to filter attributes like ['INT', 'FLOAT']

    Returns:
        list: List of tuples to be used in enum
    """
    obj = context.active_object

    enum_entries = []
    inv_data_entry = ("NULL", "[!] No valid attribues", "This list should contain all compatible attributes")

    for attrib in obj.data.attributes:
        if attrib.domain == 'POINT' and attrib.data_type in data_types:
            enum_entries.append((attrib.name, attrib.name, f"Use {attrib.name} as a source attribute"))
    
    if not len(enum_entries):
        return [inv_data_entry]
    
    return enum_entries
 
def get_attribute_comparison_conditions_enum(self,context):
    """All available conditions for attributes that store numeric values

    Args:
        context (Reference): Blender context reference

    Returns:
        list: List of tuples to be used in enum
    """
    a = context.active_object.data.attributes.active
    l = []
    for mode in data.attribute_data_types[a.data_type].supported_comparison_modes:
        l.append(data.attribute_comparison_modes[mode])
    return l


# Other

def conditional_selection_poll(self, context):
    """Used in multiple ops that are used for selecting attributes by condition on their values

    Args:
        context (Reference): Blender context reference

    Returns:
        boolean
    """
    return (context.active_object
                and context.active_object.mode == 'EDIT' 
                and context.active_object.type == 'MESH' 
                and context.active_object.data.attributes.active 
                and data.EAttributeType.NOTPROCEDURAL not in get_attribute_types(context.active_object.data.attributes.active))

def is_verbose_mode_enabled():
    """Returns a boolean if the verbose logging to console is enabled

    Returns:
        bool
    """
    return etc.get_preferences_attrib('verbose_mode')

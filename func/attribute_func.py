# Attribute related
# ------------------------------------------

# get

import random
import string
import etc.preferences
from func.obj_func import get_mesh_selected_domain_indexes
from func.util_func import color_vector_to_hsv
from modules import LEGACY_etc, LEGACY_static_data
from func.util_func import color_vector_to_rgb


def get_active_attribute(obj):
    """Bug bypass if attributes.active returns none

    Args:
        obj (ref): reference to the object to get the active attribute from
    """

    a = obj.data.attributes.active

    if a is None:
        return obj.data.attributes[obj.data.attributes.active_index]
    return a


def get_attribute_types(attribute):
    """Checks for attribute type, eg hidden, autogenerated, and other.

    Args:
        attrib_name (string): Name of the attribute

    Returns:
        list: List of data.EAttributeType
    """

    at = []

    # check for hidden
    if attribute.name.startswith('.'):
        at.append(LEGACY_static_data.EAttributeType.HIDDEN)

    # check for presets
    if attribute.name in LEGACY_static_data.built_in_attributes.keys():
            at += LEGACY_static_data.built_in_attributes[attribute.name].types
    else:
        at.append(LEGACY_static_data.EAttributeType.NORMAL)

    return at


def get_is_attribute_valid_for_manual_val_assignment(attribute):
    """Checks if the attribute is a valid attribute to assign values to it in edit mode

    Args:
        attrib_name (string): Name of the attribute

    Returns:
        list: List of data.EAttributeType
    """
    return not bool(len([atype for atype in get_attribute_types(attribute) if atype in [LEGACY_static_data.EAttributeType.READONLY, LEGACY_static_data.EAttributeType.NOTPROCEDURAL]]))


def get_attribute_value_propname(attribute = None, data_type:str = ""):
    """Gets the property name of attribute value. Some values are stored in .vector others in .value etc.

    Args:
        attribute (Reference): Attribute reference variable
        data_type (str): alternative to attribute input field

    Returns:
        string: Attribute property name
    """

    if data_type == '':
        data_type = attribute.data_type

    if data_type in ["FLOAT_VECTOR", "FLOAT2"]:
        return "vector"
    elif data_type in ["FLOAT_COLOR", "BYTE_COLOR"]:
        return "color"
    else:
        return "value"


def get_attribute_values(attribute, obj):
    """Reads all attribute values using foreach_get

    Args:
        attribute (Reference): Attribute reference variable
        obj (Reference): Reference to an 3D object that stores that attribute

    Raises:
        etc.MeshDataReadException: If source data type is not implemented

    Returns:
        list: Attribute values, data type unchanged
    """

    value_attrib_propname = get_attribute_value_propname(attribute)
    dt = attribute.data_type

    LEGACY_etc.log(get_attribute_values, f"Getting {attribute.name} values: data type = {dt} ({attribute.data_type}), prop name = {value_attrib_propname}, domain len = {len(attribute.data)}", LEGACY_etc.ELogLevel.VERBOSE)

    if dt == "FLOAT":
        a_vals = [0.0] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "INT":
        a_vals = [0] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "FLOAT_VECTOR":
        a_vals = [0.0] * (len(attribute.data) * 3) # why not Vector()? 
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2]) for i in range(0, len(a_vals), 3)]
    elif dt == "FLOAT_COLOR":
        a_vals = [0.0] * (len(attribute.data) * 4)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2], a_vals[i+3]) for i in range(0, len(a_vals), 4)]
    elif dt == "BYTE_COLOR":
        a_vals = [0.0] * (len(attribute.data) * 4)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2], a_vals[i+3]) for i in range(0, len(a_vals), 4)]
    elif dt == "BOOLEAN":
        a_vals = [False] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "FLOAT2":
        a_vals = [0.0] * (len(attribute.data) * 2)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1]) for i in range(0, len(a_vals), 2)]
    elif dt == "INT32_2D":
        a_vals = [0] * (len(attribute.data) * 2)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1]) for i in range(0, len(a_vals), 2)]
    elif dt == "QUATERNION":
        a_vals = [0.0] * (len(attribute.data) * 4)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return [(a_vals[i], a_vals[i+1], a_vals[i+2], a_vals[i+3]) for i in range(0, len(a_vals), 4)]
    elif dt == "FLOAT4X4":
        a_vals = [0.0] * (len(attribute.data) * 16)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        a = []
        for i in range(0, len(a_vals), 16):
            v = []
            for j in range(0, 16):
                v.append(a_vals[i+j])
            a.append(v)
        return a
    elif dt == "INT8":
        a_vals = [0] * len(attribute.data)
        attribute.data.foreach_get(value_attrib_propname, a_vals)
        return a_vals
    elif dt == "STRING":
        # Foreach set get does not support strings.
        a_vals = []
        for entry in attribute.data:
            a_vals.append(entry.value)
        return a_vals
    else:
        raise LEGACY_etc.exceptions.MeshDataReadException('get_attrib_values', f"Data type {dt} is unsupported.")


def get_attribute_default_value(attribute = None, datatype:str = None):
    """Returns the zero value for attribute data type. Does not return a list with the length of the attribute data!

    Args:
        attribute (Reference): Reference to the attribute
        or
        datatype (str): name of the datatype

    Raises:
        etc.MeshDataReadException: If source data type is not implemented

    Returns:
        Variable type: The default value for single attribute value
    """
    if attribute is not None:
        datatype = attribute.data_type

    if datatype in LEGACY_static_data.attribute_data_types:
        return LEGACY_static_data.attribute_data_types[datatype].default_value
    else:
        raise LEGACY_etc.exceptions.MeshDataReadException('get_attrib_default_value', f"Data type {datatype} is unsupported.")


def get_safe_attrib_name(obj, attribute_name, suffix = "Attribute", check_attributes = False):
    """Gets safe attribute name to avoid crashes in some instances.
    ie. Naming attribute the same name as Vertex Group can crash blender.

    Args:
        obj (Reference): 3D Object reference
        attribute_name (str): Name of the attribute to check
        suffix (str, optional): The suffix to add to the name if the name is not safe. Defaults to "Attribute".

    Returns:
        str: Safe attribute name
    """
    while(attribute_name in obj.vertex_groups.keys()):
            LEGACY_etc.log(get_safe_attrib_name, f"{attribute_name} exists in vertex groups! Renaming", LEGACY_etc.ELogLevel.VERBOSE)
            attribute_name += " " + suffix

    if check_attributes:
        while(attribute_name in obj.data.attributes):
                LEGACY_etc.log(get_safe_attrib_name, f"{attribute_name} exists in attributes! Renaming", LEGACY_etc.ELogLevel.VERBOSE)
                attribute_name += " " + suffix

    if attribute_name.startswith('.'):
        LEGACY_etc.log(get_safe_attrib_name, f"{attribute_name} starts with a dot, renaming", LEGACY_etc.ELogLevel.VERBOSE)
        attribute_name = attribute_name[1:]


    return attribute_name


def get_random_attribute_of_data_type(context, data_type:str, count=1, no_list = False, src_attribute = None, obj = None, randomize_once = False, no_numpy = False, **kwargs):
    """Returns a list or a single random value of specified data type.

    Args:
        obj (Reference): 3D Object Reference
        data_type (str): Data type string
        count (int): count, set higher than 1 to get a list
        no_list (boolean): Force return a single value instead of a list
        src_attribute (reference): If only a part of the vector has to be randomized the attribute has to be passed 
        obj (reference): If only a part of the vector has to be randomized the object reference has to be passed 
        randomize_once (bool): For lists, returns a single random value repeated for whole length of the list
        no_numpy (bool): If the returned value cannot be of numpy type eg. numpy.int32

        kwargs: (If applicable)
        * range_min                 The minimum random value or length for string
        * range_min                 The maximum random value or length for string
        * bool_probability          The percentage chance of getting a true value
        * string_capital            Whether to use captial letters in strings
        * string_lowercase          Whether to use lowercase letters in strings
        * string_numbers            Whether to use numbers in strings
        * string_special            Whether to use special characters in strings
        * string_custom             Use characters from input range (overrides previous toggles)
        * color_randomize_type      str RGBA HSVA
        * b_vec_{id}                Whether to change the value at vector subelement, vector is usually 4D
        * original_vector           If no_list is true, input is a vector and only some subelements have to be randomized, pass original vector here

    Returns:
        list or variable type: random value(s)
    """

    # Float
    if data_type == 'FLOAT':
        if no_list:
            random.seed()
            return random.uniform(kwargs['range_min'], kwargs['range_max'])
        elif randomize_once:
            random.seed()
            return np.repeat(random.uniform(kwargs['range_min'], kwargs['range_max']), count)
        else:
            return np.random.uniform(low=kwargs['range_min'], high=kwargs['range_max'], size=count)

    # Integers
    elif data_type in ['INT', 'INT8']:
        if no_list:
            random.seed()
            return random.randint(kwargs['range_min'], kwargs['range_max'])
        elif randomize_once:
            random.seed()
            return np.repeat(random.randint(kwargs['range_min'], kwargs['range_max']), count)
        else:
            return np.random.randint(low=kwargs['range_min'], high=kwargs['range_max'], size=count)

    # Vectors with float sub-elements
    elif data_type in ["FLOAT_VECTOR", "QUATERNION", "INT32_2D", "FLOAT_COLOR", "BYTE_COLOR", 'FLOAT2']:

        # support for single values implemented btw

        # Get number of elements to randomize
        if no_list or randomize_once:
            substack_len = 1
        else:
            substack_len = count

        use_hsv = kwargs['color_randomize_type'] == 'HSVA' and data_type in ["FLOAT_COLOR", "BYTE_COLOR"]
        v_size = len(LEGACY_static_data.attribute_data_types[data_type].vector_subelements_names)
        stacks = []

        # Check if all vector elements have to be randomized
        v_toggles = []
        for i in range(0, v_size):
            v_toggles.append(kwargs[f'b_vec_{i}'])

        # If not read the original values or get the og vector from kwargs if this is a single random vec
        if not all(v_toggles) or use_hsv:
            if no_list:
                og_vals = [kwargs['original_vector']]
            else:
                og_vals = get_attribute_values(src_attribute, obj)

        # Convert them to HSV if applicable
        if use_hsv:
            for i, subelement in enumerate(og_vals):
                og_vals[i] = color_vector_to_hsv(subelement)

        for subelement in range(0, v_size):
            if v_toggles[subelement]:
                # integer subeleemnts
                if data_type in ["INT32_2D"]:
                    stacks.append(np.random.randint(low=kwargs[f'range_min'][subelement], high=kwargs[f'range_max'][subelement], size=substack_len))

                # float subelements 
                else:
                    value = np.random.uniform(low=kwargs[f'range_min'][subelement], high=kwargs[f'range_max'][subelement], size=substack_len)

                    stacks.append(value)
            else:
                stacks.append([i[subelement] for i in og_vals])
        val = np.column_stack(stacks)

        if use_hsv:
            for i, el in enumerate(val):
                print(f'converting {el}')
                val[i] = color_vector_to_rgb(el)
        if no_list:
            return val.tolist()[0] if no_numpy else val[0]
        elif randomize_once:
            val = val.tolist()[0] if no_numpy else val[0]
            return [(val), ] * count
        else:
            return val.tolist() if no_numpy else val

    # String
    elif data_type == "STRING":
        min_len = kwargs['range_min']
        max_len = kwargs['range_max']
        custom_str = kwargs['string_custom']
        characters = []
        if custom_str is not None and custom_str !=  "":
            characters = np.array(list(custom_str)).tile(ceil(max_len/len(custom_str)))
        else:
            if kwargs['string_capital']:
                characters += string.ascii_uppercase
            if kwargs['string_lowercase']:
                characters += string.ascii_lowercase
            if kwargs['string_numbers']:
                characters += string.digits
            if kwargs['string_special']:
                characters += string.printable[62:95]

        def getrndstr(chars, max, min):
            len = round((max-min) * random.random()) + min
            start_id = random.randint(0, max-len)

            random.shuffle(chars)
            value = ''.join(chars[start_id:start_id+len+1])
            LEGACY_etc.log(get_random_attribute_of_data_type, f"MINLEN: {min}, MAXLEN:{max}, LEN:{len}, Generated string: {value}", LEGACY_etc.ELogLevel.VERBOSE)
            return value


        if no_list:
            return getrndstr(characters, max_len, min_len)
        elif randomize_once:
            return np.repeat(getrndstr(characters, max_len, min_len), count)
        else:
            a = []
            for i in range(0, count):
                a.append(getrndstr(characters, max_len, min_len))
            return a

    # Boolean
    elif data_type == "BOOLEAN":
        if no_list:
            random.seed()
            return random.uniform(0.0, 1.0) <= kwargs['bool_probability']
        elif randomize_once:
            random.seed()
            return np.repeat(random.uniform(0.0, 1.0) <= kwargs['bool_probability'], count)
        else:
            return [e <= kwargs['bool_probability'] for e in np.random.uniform(low=0.0, high=1.0, size=count)]
    else:
        raise LEGACY_etc.exceptions.GenericFunctionParameterError("get_random_attribute_of_data_type", f"Data type invalid: \"{data_type}\"")


# set

def set_attribute_values(attribute, value, sel_domain_indexes = [],
                         b_foreach_compatible_value_list = False,
                         bugbypass_data_type = "", bugbypass_domain = ""):
    """Sets attribute values. Accepts both lists and single values.
    WARNING: OBJECT MODE REQUIRED

    Args:
        attribute (Reference): Reference to the attribute
        value (list or value): The single value to set to all domains, or a list of values to set to each domain (Length has to match object domains count). Tuples are considered a single value, for use with vector attributes.
        on_indexes (list, optional): Indexes to set the value on. Defaults to []. Duplicates WILL NOT be checked, and rewritten, wasting resources
        flat_list (bool, optional): Only for setting ALL values. Used in case when the target accepts vector values (tuples), but the input list is single dimension eg. [3,3,3] instead of [(3,3,3)]. Defaults to False.
        bugbypass_data_type (str, optional): If the console returns "current value '0' matches no enum in 'ByteIntAttribute', '', 'data_type'" specify the string of the data type
        bugbypass_domain (str, optional): If the console returns "current value '0' matches no enum in 'ByteIntAttribute', '', 'data_type'" specify the string of the domain

    Raises:
        etc.MeshDataWriteException: On failure

    Returns:
        Nothing 
    """

    """
    PERFORMANCE

    For a mesh of 30,722 vertices
    Setting all values using foreach set only: ~~ 0.013s to finish (ALL values to single one)
    Setting all values using foreach get, foreach set ~~ 0.21s to finish
    Setting all values using for loop over .value ~~ 0.49s to finish

    I'm not smart enough to calculate computation complexity, but eyeballing it on multiple meshes resulted in strategy that
    <25% mesh for loop
    >25% mesh, foreach get foreach set
    all just foreach set

    setattr is noticeably slower
    """

    if value is None:
        raise LEGACY_etc.exceptions.MeshDataWriteException("set_attribute_values", f"Input value is NONE")

    # Is it a single value or a list of values to set
    b_list_of_values_input = type(value) in [list, np.ndarray]

    LEGACY_etc.log(set_attribute_values, f"Setting attribute values\n"\
            f"Attribute: {attribute.name}\n"\
            f"Value field: {value}\n"\
            f"Selected indexes: {sel_domain_indexes}\n"\
            f"foreach_set compatible list of values: {b_foreach_compatible_value_list}\n"\
            f"List of values: {b_list_of_values_input}\n"\
            f"Data Type Exception Bypass: {bugbypass_data_type != ''}\n"\
            f"Domain Exception Bypass: {bugbypass_domain != ''}\n"
            f"Force Setting By foreach On Selected: {LEGACY_etc.preferences.get_preferences_attrib('force_assign_on_selected_by_foreach_get_foreach_set')}\n"\
            f"Force Setting By Value On Selected: {LEGACY_etc.preferences.get_preferences_attrib('force_assign_on_selected_by_value')}\n", LEGACY_etc.ELogLevel.VERBOSE)

    attribute_data_type = attribute.data_type if bugbypass_data_type == '' else bugbypass_data_type
    attribute_domain = attribute.domain if bugbypass_domain == '' else bugbypass_domain

    # Case 1: overwrite all
    # Note: Strings do not support FOREACH_SET
    if (len(sel_domain_indexes) == 0 or len(sel_domain_indexes) == len(attribute.data)) and attribute_data_type != 'STRING' :

        LEGACY_etc.log(set_attribute_values, f"Using foreach_set (overwrite all)", LEGACY_etc.ELogLevel.VERBOSE)
        try:
            log_val_len = len(value)
        except TypeError:
            log_val_len = 1
        LEGACY_etc.log(set_attribute_values, f"Setting {attribute.name} attribute values for each domain. Expected data length {len(attribute.data)}, input data length {log_val_len}. Input value type {type(value)}", LEGACY_etc.ELogLevel.VERBOSE)

        # Get property name to use with foreach_set 
        prop_name = get_attribute_value_propname(data_type=attribute_data_type)

        # Create storage to use with foreach_set

        # Set the values directly
        if b_foreach_compatible_value_list:
            storage = value

        # a: The values are vector values in a list-alike container, flatten it first
        elif type(value) in [list, np.ndarray]:
            if len(value) != len(attribute.data):
                raise LEGACY_etc.exceptions.MeshDataWriteException("set_attribute_values", f"Invalid input value data length. Input {len(value)}, expected {len(attribute.data)}")

            # convert to single dimension list if of vector type
            if attribute_data_type in ['FLOAT_VECTOR', 'FLOAT2', 'FLOAT_COLOR', 'BYTE_COLOR', 'INT32_2D', 'QUATERNION', 'FLOAT4X4']:
                storage = np.array(value).flatten()
            else:
                storage = value

        # b: This is a single value, duplicate it for each domain
        else:
            storage = np.tile(value, len(attribute.data))

        if LEGACY_etc.preferences.get_preferences_attrib("en_slow_logging_ops"):
            LEGACY_etc.log(set_attribute_values, f"Internal array ({len(storage)}): {storage}", LEGACY_etc.ELogLevel.SUPER_VERBOSE)

        attribute.data.foreach_set(prop_name, storage)

    # Case 2: On selected indexes
    else:
        LEGACY_etc.log(set_attribute_values, f"Setting {attribute.name} attribute values for {len(sel_domain_indexes)} domains.", LEGACY_etc.ELogLevel.VERBOSE)
        prop = get_attribute_value_propname(data_type=attribute_data_type)

        # Method 1: FOREACH_GET_FOREACH_SET (for > 25%)
        # Slower for smaller selections, faster for larger selections
        # Note: Strings do not support FOREACH_SET
        use_foreach_get_threshold = LEGACY_etc.preferences.get_preferences_attrib('set_algo_tweak')

        if (# If the selection length is larger than a threshold in foreach_get_threshold (percent)
            len(sel_domain_indexes) > len(attribute.data)*use_foreach_get_threshold
            # Data type is not string
            and attribute_data_type != 'STRING'
            # Preferences do not force setting by value
            and not LEGACY_etc.preferences.get_preferences_attrib('force_assign_on_selected_by_value')) or(
            # Or preferences do force usage of this method
            LEGACY_etc.preferences.get_preferences_attrib('force_assign_on_selected_by_foreach_get_foreach_set')
            ):

            LEGACY_etc.log(set_attribute_values, f"Using foreach_set (on selected indexes)", LEGACY_etc.ELogLevel.VERBOSE)
            prop_name = get_attribute_value_propname(data_type=attribute_data_type)

            if b_list_of_values_input and len(value) < len(sel_domain_indexes):
                raise LEGACY_etc.exceptions.MeshDataWriteException("set_attribute_values", f"Value input list is shorter [{len(value)}] than index list that the values are supposed to be set on [{len(sel_domain_indexes)}]")

            example_attribute_domain_value = value[0] if b_list_of_values_input else value
            storage = np.repeat(example_attribute_domain_value, len(attribute.data))
            attribute.data.foreach_get(prop_name, storage)

            if type(example_attribute_domain_value) in [tuple, list, np.ndarray]:
                for i, id in enumerate(sel_domain_indexes):
                    for l in range(0, len(example_attribute_domain_value)):
                        storage[id*len(example_attribute_domain_value)+l] = value[i][l] if b_list_of_values_input else value[l]
            else:
                for i, id in enumerate(sel_domain_indexes):
                    storage[id] = value[i] if b_list_of_values_input else value
            attribute.data.foreach_set(prop_name, storage)

        # Method 2: For loop for < 25% mesh selected
        # Slower for larger selections, faster for smaller selections
        else:
            LEGACY_etc.log(set_attribute_values, "Using assign by value", LEGACY_etc.ELogLevel.VERBOSE)

            # If the attribute data type is FLOAT4X4, it needs to be adjusted
            if attribute_data_type == 'FLOAT4X4':
                fixed_value = []
                for i in range(0,4):
                    fixed_value.append((value[i*4], value[i*4+1], value[i*4+2], value[i*4+3]))
                value = tuple(fixed_value)

            # Assigning by value
            if prop == "vector":
                for i, id in enumerate(sel_domain_indexes):
                    attribute.data[id].vector = value[i] if b_list_of_values_input else value
            elif prop == "color":
                for i, id in enumerate(sel_domain_indexes):
                    attribute.data[id].color = value[i] if b_list_of_values_input else value
            else: # "value"
                for i, id in enumerate(sel_domain_indexes):
                    attribute.data[id].value = value[i] if b_list_of_values_input else value


def set_attribute_value_on_selection(self, context, obj, attribute, value, face_corner_spill = False):
    """Assigns a single value to all selected domains in edit mode.

    Args:
        context (Reference): Blender context referene
        obj (Reference): 3D Object Reference
        attribute (Reference): Attribute reference
        value (Variable type): The value to set
        face_corner_spill (bool, optional): Enable spilling the value to nearby face corners. Defaults to False.

    Returns:
        bool: Success status
    """

    # Store active attribute name (and test it) !important
    active_attrib_name = attribute.name
    active_attrib = obj.data.attributes[active_attrib_name]

    LEGACY_etc.log(set_attribute_value_on_selection, f"Working on {active_attrib_name} attribute, {obj.name}", LEGACY_etc.ELogLevel.VERBOSE)

    # Get selection in edit mode, on attribute domain
    selected_el = get_mesh_selected_domain_indexes(obj, active_attrib.domain, face_corner_spill)

    if not len(selected_el):
        self.report({'ERROR'}, "Invalid selection or no selection")
        return False

    active_attrib = obj.data.attributes[active_attrib_name] # !important get_mesh_selected_by_domain changes the reference


    a_vals = get_attribute_values(attribute, obj) if LEGACY_etc.is_full_logging_enabled() else "*skipped*"

    LEGACY_etc.log(set_attribute_value_on_selection, f"Attribute data length: {len(active_attrib.data)}"\
            f"Selected domains: [{len(selected_el)} total] - {selected_el}"\
                f"Setting value: {value}"\
                f"Pre-set values:\n{str(a_vals)}", LEGACY_etc.ELogLevel.SUPER_VERBOSE)

    # Write the new values
    #selected_el = [i for i, el in enumerate(selected_el) if el]
    #selected_el = [i.index for i in selected_el]
    set_attribute_values(active_attrib, value, selected_el)

    a_vals = get_attribute_values(attribute, obj) if LEGACY_etc.is_full_logging_enabled() else "*skipped*"
    LEGACY_etc.log(set_attribute_value_on_selection, f"Post-set values:\n{str(a_vals)}", LEGACY_etc.ELogLevel.SUPER_VERBOSE)
    return True


def set_active_attribute(obj, attribute_name):
    """Sets active attribute and avoids the bug that might set the invalid attribute as active

    Args:
        obj (Reference): Object Reference
        attribute_name (str): Attribute name
    """

    atrr_index = obj.data.attributes.keys().index(attribute_name)
    LEGACY_etc.log(set_active_attribute, f"Setting active attribute to {attribute_name}, index {atrr_index}", LEGACY_etc.ELogLevel.VERBOSE)
    obj.data.attributes.active_index = atrr_index


def convert_attribute(self, obj, attrib_name, mode, domain, data_type):
    """Converts attribute to different type

    Args:
        obj (Reference): 3D Object Reference
        attrib_name (str): Name of the attribute
        mode (enum str): See data.convert_attribute_modes
        domain (enum str): See data.attribute_domains
        data_type (enum str): See data.attribute_data_types

    Raises:
        etc.MeshDataWriteException: On failure
    """

    LEGACY_etc.log(convert_attribute, f"Converting attribute {attrib_name}", LEGACY_etc.ELogLevel.VERBOSE)

    # Auto convert to different data type, if enabled in gui
    attrib = obj.data.attributes[attrib_name]

    if attrib is not None:
        set_active_attribute(obj, attrib_name)

        LEGACY_etc.log(convert_attribute, f"Converting {obj.data.attributes.active.name} with settings {mode}, {domain}, {data_type}. Viewport mode: {obj.mode}", LEGACY_etc.ELogLevel.VERBOSE)

        bpy.ops.geometry.attribute_convert(mode=mode, domain=domain, data_type=data_type)
    else:
        raise LEGACY_etc.exceptions.MeshDataWriteException('convert_attribute', f"{attrib_name} attribute is None?")